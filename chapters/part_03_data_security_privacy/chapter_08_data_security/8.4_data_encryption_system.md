# 8.4 数据加密体系

## Data Encryption System

加密是数据保护的核心技术控制，在访问控制失效、网络边界被突破的场景下仍能保障数据机密性。本节阐述静态加密、传输加密、使用中加密的技术实现，以及密钥管理体系的设计与运行要求。

---

## 8.4.1 加密体系架构

### 三层加密防护模型

企业数据加密需覆盖数据在传输、存储、计算三个状态下的保护需求。三层防护模型将加密控制嵌入数据流动的不同阶段，避免单点防护失效导致数据暴露。

![数据加密架构](../../../assets/images/chapter_08/02_Data_Encryption_Architecture_v6.png)

图 8.2：数据加密架构 - 传输加密、静态加密、使用中加密三层防护体系

```
┌──────────────────────────────────────────────────────────┐
│ 企业数据加密三层防护模型                                  │
│ (Data Encryption Defense-in-Depth Model)                 │
├──────────────────────────────────────────────────────────┤
│                                                            │
│ [第一层] 传输加密 (Encryption in Transit)                │
│ ├─ 目标：保护数据在网络传输过程中不被窃听/篡改          │
│ ├─ 技术：TLS 1.3、mTLS、IPSec VPN、WireGuard            │
│ ├─ 适用：HTTPS、API 调用、数据库连接、跨区域同步        │
│ └─ 威胁：中间人攻击 (MITM)、网络监听、流量劫持          │
│                                                            │
│ [第二层] 静态加密 (Encryption at Rest)                   │
│ ├─ 目标：保护存储介质上的数据(磁盘、备份、归档)        │
│ ├─ 技术：AES-256、database TDE、文件系统加密、云加密   │
│ ├─ 适用：数据库、文件存储、对象存储、备份、日志        │
│ └─ 威胁：存储介质盗窃、备份泄露、云存储错误配置        │
│                                                            │
│ [第三层] 使用中加密 (Encryption in Use)                  │
│ ├─ 目标：在数据处理/计算过程中保持加密状态              │
│ ├─ 技术：同态加密 (HE)、安全多方计算 (MPC)、可信执行环境│
│ ├─ 适用：云 AI 训练、多方数据协作、敏感数据分析          │
│ └─ 威胁：内存 dump、进程劫持、恶意管理员                │
│                                                            │
│ [核心支撑] 密钥管理 (Key Management)                      │
│ ├─ KMS：密钥生成、存储、轮换、销毁                      │
│ ├─ HSM：硬件安全模块，防物理攻击                        │
│ ├─ 密钥层级：根密钥 (KEK) → 数据密钥 (DEK)               │
│ └─ 访问控制：RBAC + 审计 + 双人管理                     │
│                                                            │
└──────────────────────────────────────────────────────────┘
```

### 加密决策矩阵

基于数据分类等级选择加密强度与密钥管理策略。下表提供典型配置，实际部署需结合业务延迟容忍度与合规要求调整。

| 数据分类     | 静态加密                   | 传输加密                   | 使用中加密               | 密钥管理              |
| ------------ | -------------------------- | -------------------------- | ------------------------ | --------------------- |
| Restricted   | 必需`<br>`AES-256        | 必需`<br>`TLS 1.3 + mTLS | 推荐`<br>`同态加密/TEE | HSM`<br>`90 天轮换  |
| Confidential | 必需`<br>`AES-256        | 必需`<br>`TLS 1.2+       | 通常不需要               | KMS`<br>`180 天轮换 |
| Internal     | 推荐`<br>`AES-256        | 必需`<br>`TLS 1.2+       | 不需要                   | KMS`<br>`年度轮换   |
| Public       | 不需要`<br>`（完整性保护） | 推荐`<br>`TLS 1.2+       | 不需要                   | -                     |

**约束条件**：

- 性能影响：字段级加密会导致数据库查询无法使用索引，需在加密粒度与查询性能间权衡。
- 密钥轮换停机：密钥轮换过程中需重新加密数据，若未设计在线轮换机制，可能需要业务停机窗口。
- 合规强制性：金融行业 (PCI DSS)、医疗行业 (HIPAA) 对加密算法与密钥长度有强制要求，不可降级。

**验证方法**：

- 使用流量抓包工具（如 Wireshark）验证 TLS 版本与密码套件配置是否符合预期。
- 对加密存储执行物理介质提取测试，验证未持有密钥时数据不可读。
- 红队模拟内存 dump 攻击，测试密钥是否在内存中明文存储。

**运行指标**：

- 加密覆盖率：已加密数据占全部敏感数据的百分比（按数据分类等级统计）。
- 密钥轮换达标率：按计划完成轮换的密钥占比。
- 加密性能影响：加密后数据库查询延迟增量（P50/P95/P99 分位值）。

---

## 8.4.2 静态加密 (Encryption at Rest)

### 数据库透明数据加密 (TDE - Transparent Data Encryption)

TDE 在数据写入磁盘时自动加密，读取时自动解密，对应用层透明。适用于需要保护整个数据库或表空间的场景，但无法实现字段级访问控制。

#### PostgreSQL TDE 实现

PostgreSQL 原生不支持 TDE，需通过 pgcrypto 扩展实现字段级加密。以下示例展示加密敏感字段的典型流程。

```sql
-- PostgreSQL 透明数据加密配置

-- 1. 创建加密密钥(使用pgcrypto扩展)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 2. 创建密钥表(存储在 HSM 或 KMS)
CREATE TABLE encryption_keys (
    key_id SERIAL PRIMARY KEY,
    key_name VARCHAR(100) UNIQUE,
    encrypted_key BYTEA, -- 使用 KEK 加密的 DEK
    created_at TIMESTAMP DEFAULT NOW(),
    rotated_at TIMESTAMP,
    status VARCHAR(20) DEFAULT 'Active'
);

-- 3. 创建加密表
CREATE TABLE customer_sensitive (
    id SERIAL PRIMARY KEY,
    user_id INT,
    -- 加密列使用BYTEA类型存储
    email_encrypted BYTEA,
    credit_card_encrypted BYTEA,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 4. 插入数据时加密
-- 使用对称加密 (AES-256)
CREATE OR REPLACE FUNCTION encrypt_aes256(plaintext TEXT, key_name TEXT)
RETURNS BYTEA AS $$
DECLARE
    encryption_key BYTEA;
BEGIN
    -- 从 KMS 获取 DEK（简化示例，生产环境应调用 KMS API 如 AWS KMS、HashiCorp Vault）
    SELECT decrypt(encrypted_key, 'KEK_from_HSM') INTO encryption_key
    FROM encryption_keys
    WHERE key_name = key_name AND status = 'Active';

    -- 使用 AES-256-GCM 加密
    RETURN pgp_sym_encrypt(plaintext, encryption_key::TEXT);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 插入加密数据
INSERT INTO customer_sensitive (user_id, email_encrypted, credit_card_encrypted)
VALUES (
    123,
    encrypt_aes256('user@example.com', 'customer_data_key'),
    encrypt_aes256('4111111111111111', 'payment_data_key')
);

-- 5. 查询数据时解密
CREATE OR REPLACE FUNCTION decrypt_aes256(ciphertext BYTEA, key_name TEXT)
RETURNS TEXT AS $$
DECLARE
    encryption_key BYTEA;
BEGIN
    SELECT decrypt(encrypted_key, 'KEK_from_HSM') INTO encryption_key
    FROM encryption_keys
    WHERE key_name = key_name AND status = 'Active';

    RETURN pgp_sym_decrypt(ciphertext, encryption_key::TEXT);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 查询解密数据（需授权）
SELECT
    id,
    user_id,
    decrypt_aes256(email_encrypted, 'customer_data_key') AS email,
    CASE
        WHEN current_user IN ('admin', 'compliance_officer')
        THEN decrypt_aes256(credit_card_encrypted, 'payment_data_key')
        ELSE '****-****-****-' || RIGHT(decrypt_aes256(credit_card_encrypted, 'payment_data_key'), 4)
    END AS credit_card
FROM customer_sensitive
WHERE user_id = 123;
```

**适用边界**：

- 适用于需要保护整个表或特定字段的场景，不适用于需要频繁范围查询或模糊查询的字段（因加密后无法使用索引）。
- 需要应用层或数据库函数参与加解密，不是完全透明的 TDE。

**常见误区**：

1. 加密函数未使用 SECURITY DEFINER，导致普通用户可以直接调用解密函数绕过访问控制。
2. 密钥直接硬编码在函数中，而非从 KMS 动态获取，导致密钥泄露风险。

#### MySQL TDE 配置

MySQL Enterprise 版本原生支持 TDE，通过 keyring 插件管理密钥。

```sql
-- MySQL Enterprise TDE (需 Enterprise 版本)

-- 1. 安装 keyring 插件
INSTALL PLUGIN keyring_file SONAME 'keyring_file.so';

-- 2. 配置 my.cnf
/*
[mysqld]
early-plugin-load=keyring_file.so
keyring_file_data=/var/lib/mysql-keyring/keyring
*/

-- 3. 创建加密表
CREATE TABLE customer_pii (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255),
    ssn VARCHAR(11),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENCRYPTION='Y';  -- 启用加密

-- 4. 加密现有表
ALTER TABLE existing_table ENCRYPTION='Y';

-- 5. 验证加密状态
SELECT
    TABLE_SCHEMA,
    TABLE_NAME,
    CREATE_OPTIONS
FROM information_schema.TABLES
WHERE CREATE_OPTIONS LIKE '%ENCRYPTION%';
```

**约束条件**：

- MySQL TDE 仅 Enterprise 版本支持，社区版需通过文件系统加密或应用层加密实现。
- 加密后表空间文件大小会增加（通常 5%-10%），需预留存储空间。

### 文件系统加密

#### Linux LUKS 全盘加密

LUKS (Linux Unified Key Setup) 提供块设备级加密，适用于保护服务器本地磁盘或虚拟机磁盘镜像。

```bash
# 使用 LUKS (Linux Unified Key Setup) 加密磁盘

# 1. 创建加密分区
cryptsetup luksFormat /dev/sdb1
# 输入密码: ********

# 2. 打开加密分区
cryptsetup luksOpen /dev/sdb1 encrypted_data

# 3. 创建文件系统
mkfs.ext4 /dev/mapper/encrypted_data

# 4. 挂载
mkdir /mnt/secure_data
mount /dev/mapper/encrypted_data /mnt/secure_data

# 5. 查看加密状态
cryptsetup status encrypted_data
# Output:
# /dev/mapper/encrypted_data is active and is in use.
# type: LUKS2
# cipher: aes-xts-plain64
# keysize: 512 bits

# 6. 添加备份密钥槽（防止主密钥丢失）
cryptsetup luksAddKey /dev/sdb1

# 7. 卸载与关闭
umount /mnt/secure_data
cryptsetup luksClose encrypted_data
```

**验证方法**：

- 使用 `cryptsetup luksDump /dev/sdb1` 查看密钥槽配置与加密算法。
- 模拟磁盘盗窃场景：将加密磁盘挂载到未授权系统，验证无法读取数据。

#### 云存储加密配置

云对象存储（如 AWS S3）提供服务端加密 (SSE) 与客户端加密 (CSE) 两种模式。服务端加密由云提供商管理密钥，客户端加密由用户控制密钥。

```python
# AWS S3 服务端加密 (SSE) 配置

import boto3
import json

s3 = boto3.client('s3')
kms = boto3.client('kms')

class S3EncryptionManager:
    """S3加密管理"""

    def create_encrypted_bucket(self, bucket_name, classification):
        """创建加密存储桶"""

        # 创建存储桶
        s3.create_bucket(Bucket=bucket_name)

        # 根据数据分类选择加密方式
        if classification == 'Restricted':
            # 方式 1: SSE-KMS（客户管理密钥 CMK）
            # 创建 KMS 密钥
            key_response = kms.create_key(
                Description=f'Encryption key for {bucket_name}',
                KeyUsage='ENCRYPT_DECRYPT',
                Origin='AWS_KMS',
                MultiRegion=False,
                Tags=[
                    {'TagKey': 'Classification', 'TagValue': 'Restricted'},
                    {'TagKey': 'Bucket', 'TagValue': bucket_name}
                ]
            )
            kms_key_id = key_response['KeyMetadata']['KeyId']

            # 配置存储桶默认加密
            s3.put_bucket_encryption(
                Bucket=bucket_name,
                ServerSideEncryptionConfiguration={
                    'Rules': [{
                        'ApplyServerSideEncryptionByDefault': {
                            'SSEAlgorithm': 'aws:kms',
                            'KMSMasterKeyID': kms_key_id
                        },
                        'BucketKeyEnabled': True  # 减少 KMS API 调用
                    }]
                }
            )

            # 配置 KMS 密钥策略（限制访问）
            key_policy = {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Sid": "Enable IAM User Permissions",
                        "Effect": "Allow",
                        "Principal": {"AWS": "arn:aws:iam::123456789:root"},
                        "Action": "kms:*",
                        "Resource": "*"
                    },
                    {
                        "Sid": "Allow use of the key for S3",
                        "Effect": "Allow",
                        "Principal": {"Service": "s3.amazonaws.com"},
                        "Action": ["kms:Decrypt", "kms:GenerateDataKey"],
                        "Resource": "*",
                        "Condition": {
                            "StringEquals": {
                                "kms:ViaService": f"s3.us-east-1.amazonaws.com"
                            }
                        }
                    }
                ]
            }
            kms.put_key_policy(
                KeyId=kms_key_id,
                PolicyName='default',
                Policy=json.dumps(key_policy)
            )

        elif classification in ['Confidential', 'Internal']:
            # 方式 2: SSE-S3（AWS 管理密钥）
            s3.put_bucket_encryption(
                Bucket=bucket_name,
                ServerSideEncryptionConfiguration={
                    'Rules': [{
                        'ApplyServerSideEncryptionByDefault': {
                            'SSEAlgorithm': 'AES256'
                        }
                    }]
                }
            )

        # 配置存储桶策略：拒绝未加密上传
        bucket_policy = {
            "Version": "2012-10-17",
            "Statement": [{
                "Sid": "DenyUnencryptedObjectUploads",
                "Effect": "Deny",
                "Principal": "*",
                "Action": "s3:PutObject",
                "Resource": f"arn:aws:s3:::{bucket_name}/*",
                "Condition": {
                    "StringNotEquals": {
                        "s3:x-amz-server-side-encryption": ["AES256", "aws:kms"]
                    }
                }
            }]
        }
        s3.put_bucket_policy(
            Bucket=bucket_name,
            Policy=json.dumps(bucket_policy)
        )

        return {
            'bucket': bucket_name,
            'encryption': 'Enabled',
            'kms_key': kms_key_id if classification == 'Restricted' else None
        }

    def upload_encrypted_object(self, bucket, key, file_path, classification):
        """上传加密对象"""

        extra_args = {}

        if classification == 'Restricted':
            # 客户端加密 (CSE) + 服务端加密 (SSE-KMS) 双重保护
            # 注意：这里简化示例，生产环境应使用 AWS Encryption SDK
            extra_args = {
                'ServerSideEncryption': 'aws:kms',
                'SSEKMSKeyId': 'arn:aws:kms:region:account:key/xxx'
            }
        else:
            extra_args = {
                'ServerSideEncryption': 'AES256'
            }

        s3.upload_file(
            file_path,
            bucket,
            key,
            ExtraArgs=extra_args
        )

        return {'bucket': bucket, 'key': key, 'encrypted': True}

# 使用示例
manager = S3EncryptionManager()
manager.create_encrypted_bucket('customer-data-restricted', 'Restricted')
manager.upload_encrypted_object('customer-data-restricted', 'data/customer_pii.csv', '/local/file.csv', 'Restricted')
```

**适用边界**：

- SSE-S3 适用于不需要审计密钥使用记录的场景，密钥由 AWS 全托管。
- SSE-KMS 适用于需要审计密钥访问、控制密钥权限、满足合规要求的场景。
- CSE 适用于对云提供商不完全信任的场景，密钥完全由客户控制。

**常见误区**：

1. 启用存储桶默认加密后未配置拒绝未加密上传的策略，导致旧版 SDK 或错误配置仍可上传明文对象。
2. SSE-KMS 密钥策略未限制 `kms:ViaService` 条件，导致任意服务可使用该密钥。

---

## 8.4.3 传输加密 (Encryption in Transit)

### TLS 1.3 深度配置

TLS 1.3 相比 TLS 1.2 移除了不安全的密码套件（如 RC4、3DES），简化握手流程，减少往返延迟。企业应强制使用 TLS 1.3 或至少 TLS 1.2。

#### 现代密码套件选择

```
推荐密码套件（按优先级排序）:

1. TLS 1.3（最优先）
   - TLS_AES_256_GCM_SHA384
   - TLS_CHACHA20_POLY1305_SHA256
   - TLS_AES_128_GCM_SHA256

2. TLS 1.2（兼容性）
   - ECDHE-RSA-AES256-GCM-SHA384
   - ECDHE-RSA-AES128-GCM-SHA256
   - ECDHE-RSA-CHACHA20-POLY1305

禁用套件（不安全）:
   - RC4（已破解）
   - 3DES（密钥长度不足）
   - MD5/SHA1（哈希碰撞）
   - Export 级别密码（弱密码）
```

#### Apache HTTPD TLS 配置

```apache
# Apache 2.4 强化 TLS 配置

<VirtualHost *:443>
    ServerName secure.example.com

    # 1. 证书配置
    SSLEngine on
    SSLCertificateFile /path/to/fullchain.pem
    SSLCertificateKeyFile /path/to/privkey.pem
    SSLCertificateChainFile /path/to/chain.pem

    # 2. 协议版本
    SSLProtocol -all +TLSv1.3 +TLSv1.2

    # 3. 密码套件
    SSLCipherSuite TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-RSA-AES256-GCM-SHA384
    SSLHonorCipherOrder on

    # 4. OCSP Stapling
    SSLUseStapling on
    SSLStaplingCache "shmcb:logs/ssl_stapling(32768)"

    # 5. Session Cache
    SSLSessionCache "shmcb:logs/ssl_scache(512000)"
    SSLSessionCacheTimeout 300

    # 6. HSTS
    Header always set Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"

    # 7. 禁用不安全功能
    SSLCompression off
    SSLOptions +StrictRequire

    # 8. 日志
    CustomLog logs/ssl_access_log combined
    ErrorLog logs/ssl_error_log
    LogLevel warn

    # 9. 客户端证书验证（mTLS，可选）
    # SSLVerifyClient require
    # SSLVerifyDepth 2
    # SSLCACertificateFile /path/to/ca-bundle.crt
</VirtualHost>
```

**验证方法**：

- 使用 `openssl s_client -connect secure.example.com:443 -tls1_3` 验证 TLS 1.3 支持。
- 使用 SSL Labs（ssllabs.com/ssltest/ 为 Qualys 公开服务）扫描服务器 TLS 配置评分。
- 使用 testssl.sh 开源工具全面检查 TLS 配置漏洞。

### 双向 TLS (mTLS - Mutual TLS)

mTLS 要求客户端与服务端互相验证证书，适用于服务间通信、API 认证、零信任架构。

```python
# Python mTLS 服务端配置

import ssl
from flask import Flask, request

app = Flask(__name__)

def create_mtls_context():
    """创建 mTLS 上下文"""

    # 创建 SSL 上下文
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)

    # 加载服务端证书
    context.load_cert_chain(
        certfile='/path/to/server.crt',
        keyfile='/path/to/server.key'
    )

    # 加载 CA 证书（用于验证客户端证书）
    context.load_verify_locations(cafile='/path/to/ca.crt')

    # 要求客户端提供证书
    context.verify_mode = ssl.CERT_REQUIRED

    # 设置协议版本
    context.minimum_version = ssl.TLSVersion.TLSv1_3

    # 设置密码套件
    context.set_ciphers('TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256')

    return context

@app.route('/api/sensitive-data')
def sensitive_api():
    """受 mTLS 保护的 API"""

    # 获取客户端证书信息
    client_cert = request.environ.get('SSL_CLIENT_CERT')
    client_cn = request.environ.get('SSL_CLIENT_S_DN_CN')

    # 验证客户端身份
    if client_cn not in ['service-a', 'service-b', 'authorized-client']:
        return {'error': 'Unauthorized client'}, 403

    # 返回敏感数据
    return {'data': 'sensitive information', 'client': client_cn}

if __name__ == '__main__':
    context = create_mtls_context()
    app.run(host='0.0.0.0', port=8443, ssl_context=context)
```

```python
# Python mTLS 客户端

import requests

# 使用客户端证书
response = requests.get(
    'https://secure-api.example.com/api/sensitive-data',
    cert=('/path/to/client.crt', '/path/to/client.key'),
    verify='/path/to/ca.crt'  # 验证服务端证书
)

print(response.json())
```

**适用边界**：

- 适用于服务间通信、微服务网格、零信任架构，不适用于面向公众的 Web 服务（用户设备难以预装客户端证书）。

**常见误区**：

1. 未设置 `verify_mode = ssl.CERT_REQUIRED`，导致客户端证书验证可选而非强制。
2. CA 证书包含过多受信任根证书，导致未授权的客户端证书也能通过验证。

---

## 8.4.4 使用中加密 (Encryption in Use)

### 同态加密 (Homomorphic Encryption)

同态加密允许在加密数据上直接进行计算而无需解密，适用于云计算、多方协作场景。目前全同态加密 (FHE) 性能开销仍较大，工程实践以部分同态加密为主。

```python
# 使用 Microsoft SEAL 库的同态加密示例

from seal import *

class HomomorphicEncryption:
    """同态加密示例"""

    def __init__(self):
        # 创建加密参数
        parms = EncryptionParameters(scheme_type.bfv)
        poly_modulus_degree = 4096
        parms.set_poly_modulus_degree(poly_modulus_degree)
        parms.set_coeff_modulus(CoeffModulus.BFVDefault(poly_modulus_degree))
        parms.set_plain_modulus(512)

        # 创建上下文
        self.context = SEALContext(parms)

        # 生成密钥
        keygen = KeyGenerator(self.context)
        self.public_key = keygen.create_public_key()
        self.secret_key = keygen.secret_key()

        # 创建加密器和解密器
        self.encryptor = Encryptor(self.context, self.public_key)
        self.decryptor = Decryptor(self.context, self.secret_key)
        self.evaluator = Evaluator(self.context)

    def compute_encrypted_sum(self, value1, value2):
        """在加密数据上执行加法"""

        # 编码明文
        encoder = IntegerEncoder(self.context)
        plain1 = encoder.encode(value1)
        plain2 = encoder.encode(value2)

        # 加密
        encrypted1 = Ciphertext()
        encrypted2 = Ciphertext()
        self.encryptor.encrypt(plain1, encrypted1)
        self.encryptor.encrypt(plain2, encrypted2)

        print(f"原始值: {value1} + {value2}")
        print(f"密文 1 大小: {encrypted1.size()} bytes")

        # 在加密数据上执行加法（无需解密！）
        encrypted_result = Ciphertext()
        self.evaluator.add(encrypted1, encrypted2, encrypted_result)

        # 解密结果
        plain_result = Plaintext()
        self.decryptor.decrypt(encrypted_result, plain_result)
        result = encoder.decode_int32(plain_result)

        print(f"同态计算结果: {result}")
        return result

# 使用场景：云端计算工资总和，无需云提供商看到个人工资
he = HomomorphicEncryption()
# 工资数据加密后上传到云
total_salary = he.compute_encrypted_sum(50000, 80000)
print(f"总工资（解密后）: {total_salary}")  # 130000
```

**适用边界**：

- 适用于云端数据分析、多方协作计算，不适用于需要低延迟的实时计算场景（同态加密性能开销较大）。

**约束条件**：

- 全同态加密性能开销大（比明文计算慢 100-1000 倍），工程实践需结合业务延迟容忍度评估可行性。
- 密文膨胀：加密后数据体积增加（通常 10-100 倍），需预留存储与网络带宽。

### 可信执行环境 (TEE - Trusted Execution Environment)

TEE 通过硬件隔离技术在 CPU 内创建安全区域，数据在该区域内计算时即使操作系统被攻破也无法被窃取。

```c
// Intel SGX Enclave 示例 (简化)

/* enclave.edl - Enclave 接口定义 */
enclave {
    trusted {
        /* 在安全区域内执行的函数 */
        public int process_sensitive_data([in, size=len] uint8_t* encrypted_data, size_t len);
    };

    untrusted {
        /* 调用外部函数 */
        void log_message([in, string] const char* msg);
    };
};

/* enclave.c - Enclave 实现 */
#include "enclave_t.h"
#include <string.h>

int process_sensitive_data(uint8_t* encrypted_data, size_t len) {
    // 在 SGX Enclave 内部，数据在内存中是加密的
    // 即使操作系统或 hypervisor 被攻破，也无法读取

    uint8_t decrypted_data[1024];

    // 1. 解密数据（仅在 Enclave 内可见）
    decrypt_aes256(encrypted_data, len, decrypted_data);

    // 2. 处理敏感数据
    int sum = 0;
    for (size_t i = 0; i < len; i++) {
        sum += decrypted_data[i];
    }

    // 3. 清除内存痕迹
    memset(decrypted_data, 0, sizeof(decrypted_data));

    // 4. 记录日志（不包含敏感信息）
    log_message("Sensitive data processed successfully");

    return sum;
}
```

**适用边界**：

- 适用于云环境中对云提供商不完全信任的场景，不适用于对性能要求极高的场景（TEE 有性能开销）。

**验证方法**：

- 使用远程认证（Remote Attestation）验证代码运行在真实 TEE 环境中。
- 红队模拟内存 dump 攻击，验证 Enclave 内数据是否加密。

---

## 8.4.5 密钥管理体系 (KMS)

### 密钥层级架构

密钥管理采用层级结构，根密钥 (Root Key) 加密密钥加密密钥 (KEK)，KEK 加密数据加密密钥 (DEK)，DEK 直接加密数据。层级设计避免根密钥频繁使用，降低泄露风险。

```
┌────────────────────────────────────────────────────────┐
│ 密钥管理层级 (Key Hierarchy)                            │
├────────────────────────────────────────────────────────┤
│                                                          │
│ [Level 1] 根密钥 (Root Key / Master Key)               │
│ ├─ 存储：HSM 硬件安全模块（防物理攻击）                   │
│ ├─ 用途：仅用于加密/解密 KEK                             │
│ ├─ 生命周期：长期（3-5 年），极少轮换                     │
│ └─ 访问：双人授权，审计记录                             │
│ ↓ 加密                                                  │
│ [Level 2] 密钥加密密钥 (KEK - Key Encryption Key)      │
│ ├─ 存储：加密后存储在 KMS 数据库                         │
│ ├─ 用途：加密/解密 DEK                                   │
│ ├─ 生命周期：1-2 年，定期轮换                           │
│ └─ 访问：服务账号，自动化轮换                           │
│ ↓ 加密                                                  │
│ [Level 3] 数据加密密钥 (DEK - Data Encryption Key)     │
│ ├─ 存储：加密后与数据一起存储（Envelope Encryption）    │
│ ├─ 用途：直接加密/解密数据                             │
│ ├─ 生命周期：90-180 天，自动轮换                        │
│ └─ 访问：应用服务，按需获取                             │
│ ↓ 加密                                                  │
│ [Level 4] 数据 (Encrypted Data)                         │
│ └─ 存储：数据库、文件系统、对象存储                     │
│                                                          │
└────────────────────────────────────────────────────────┘
```

### 信封加密 (Envelope Encryption)

信封加密使用 DEK 加密数据，使用 KEK 加密 DEK，避免频繁调用 HSM。DEK 密文与加密数据一起存储，解密时先用 KEK 解密 DEK，再用 DEK 解密数据。

```python
# 信封加密实现

import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import boto3
import base64

class EnvelopeEncryption:
    """信封加密实现"""

    def __init__(self, kms_key_id):
        self.kms = boto3.client('kms')
        self.kms_key_id = kms_key_id

    def encrypt_data(self, plaintext_data):
        """加密数据"""

        # 步骤 1：调用 KMS 生成数据密钥 DEK
        response = self.kms.generate_data_key(
            KeyId=self.kms_key_id,
            KeySpec='AES_256'  # 生成 256 位 AES 密钥
        )

        # DEK 明文（仅在内存中，用完立即销毁）
        dek_plaintext = response['Plaintext']

        # DEK 密文（使用 KEK 加密，安全存储）
        dek_ciphertext = response['CiphertextBlob']

        # 步骤 2：使用 DEK 加密数据 (AES-256-GCM)
        iv = os.urandom(12)  # GCM 模式 IV
        cipher = Cipher(
            algorithms.AES(dek_plaintext),
            modes.GCM(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(plaintext_data) + encryptor.finalize()

        # 步骤 3：清除内存中的 DEK 明文
        dek_plaintext = None

        # 返回：加密数据 + 加密的 DEK + IV + Tag
        return {
            'ciphertext': base64.b64encode(ciphertext).decode('utf-8'),
            'encrypted_dek': base64.b64encode(dek_ciphertext).decode('utf-8'),
            'iv': base64.b64encode(iv).decode('utf-8'),
            'tag': base64.b64encode(encryptor.tag).decode('utf-8')
        }

    def decrypt_data(self, encrypted_data):
        """解密数据"""

        # 步骤 1：调用 KMS 解密 DEK
        dek_ciphertext = base64.b64decode(encrypted_data['encrypted_dek'])
        response = self.kms.decrypt(CiphertextBlob=dek_ciphertext)
        dek_plaintext = response['Plaintext']

        # 步骤 2：使用 DEK 解密数据
        ciphertext = base64.b64decode(encrypted_data['ciphertext'])
        iv = base64.b64decode(encrypted_data['iv'])
        tag = base64.b64decode(encrypted_data['tag'])

        cipher = Cipher(
            algorithms.AES(dek_plaintext),
            modes.GCM(iv, tag),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()

        # 步骤 3：清除 DEK 明文
        dek_plaintext = None

        return plaintext

# 使用示例（注意：kms_key_id 需替换为实际 KMS 密钥 ARN）
envelope = EnvelopeEncryption(kms_key_id='arn:aws:kms:us-east-1:123456:key/xxx')

# 加密
plaintext = b"Sensitive customer data"
encrypted = envelope.encrypt_data(plaintext)
print(f"Encrypted DEK: {encrypted['encrypted_dek'][:50]}...")

# 解密
decrypted = envelope.decrypt_data(encrypted)
print(f"Decrypted: {decrypted.decode('utf-8')}")
```

**验证方法**：

- 验证 DEK 明文是否在加密/解密操作后立即清除，避免内存泄露。
- 验证加密数据与 DEK 密文分离存储，避免同时泄露导致数据破解。

### 密钥轮换策略

密钥轮换周期基于风险容忍度与合规要求设定。高敏感数据密钥轮换周期更短，但需权衡轮换成本与业务连续性。

| 密钥类型 | 轮换频率    | 轮换方式                 | 回退策略                      |
| -------- | ----------- | ------------------------ | ----------------------------- |
| Root Key | 3-5 年      | 手动，双人授权           | 保留旧密钥 6 个月             |
| KEK      | 1-2 年      | 自动化，审批流程         | 保留旧密钥 1 年               |
| DEK      | 90-180 天   | 全自动                   | 保留旧密钥直到数据 re-encrypt |
| API 密钥 | 季度        | 自动 + 手动触发          | 双密钥并行期 7 天             |
| 证书     | 1 年（建议） | 自动续期（Let's Encrypt） | 提前 30 天续期                |

**常见误区**：

1. 密钥轮换后未重新加密旧数据，导致旧数据仍使用已泄露风险的旧密钥。
2. 密钥轮换过程中未保留旧密钥，导致正在传输的数据解密失败。

**运行指标**：

- 密钥轮换达标率：按计划完成轮换的密钥占比。
- 密钥使用审计完整性：KMS API 调用日志保留期限与完整性校验通过率。

---

## 8.4.6 加密算法选择

### 对称加密算法对比

| 算法              | 密钥长度             | 安全性 | 性能            | 推荐场景       |
| ----------------- | -------------------- | ------ | --------------- | -------------- |
| AES-256-GCM       | 256 位               | 高     | 快（硬件加速）   | 首选：数据加密 |
| ChaCha20-Poly1305 | 256 位               | 高     | 快（移动设备优） | 移动应用、IoT  |
| AES-128-GCM       | 128 位               | 中     | 更快            | 性能优先场景   |
| 3DES              | 168 位（有效 112 位） | 低     | 慢              | 已弃用         |
| RC4               | 可变                 | 已破解 | -               | 禁止使用       |

### 非对称加密算法对比

| 算法      | 密钥长度 | 安全性 | 用途               | 推荐        |
| --------- | -------- | ------ | ------------------ | ----------- |
| RSA-4096  | 4096 位  | 高     | 密钥交换、数字签名 | 推荐        |
| RSA-2048  | 2048 位  | 中     | 密钥交换、数字签名 | 最低标准    |
| ECC P-256 | 256 位   | 高     | 密钥交换、签名     | 推荐（移动） |
| Ed25519   | 256 位   | 高     | 数字签名           | 推荐        |
| RSA-1024  | 1024 位  | 低     | -                  | 已弃用      |

### 哈希算法选择

| 算法    | 输出长度 | 碰撞抗性 | 用途                       | 推荐         |
| ------- | -------- | -------- | -------------------------- | ------------ |
| SHA-256 | 256 位   | 高       | 完整性校验、数字签名       | 推荐         |
| SHA-512 | 512 位   | 高       | 高安全场景                 | 推荐         |
| SHA-3   | 可变     | 高       | 下一代标准                 | 推荐         |
| bcrypt  | 60 chars | 高       | 密码 hash（慢哈希，自适应） | 密码存储首选 |
| SHA-1   | 160 位   | 已破解   | -                          | 禁止使用     |
| MD5     | 128 位   | 已破解   | -                          | 禁止使用     |

**验证方法**：

- 使用 `openssl speed` 命令测试不同算法在目标硬件上的性能。
- 参考 NIST、BSI 等机构发布的算法推荐清单，确保算法合规。

---

---

## 导航

**[← 上一节：8.3 数据生命周期安全](./8.3_data_lifecycle_security.md)** | **[返回章节目录](./README.md)** | **[下一节：8.5 数据访问控制 →](./8.5_data_access_control.md)**

---

**© 2025 AI-ESA Project. Licensed under CC BY-NC-SA 4.0**
