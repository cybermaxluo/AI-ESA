# 8.3 数据生命周期安全

## Data Lifecycle Security

数据从创建到销毁经历完整的生命周期。本节从企业数据治理视角，阐述数据在创建、存储、传输、使用、归档、销毁六个阶段的安全控制设计，包括每个阶段的关键约束、技术选型权衡、验证方法与运行指标。目标是建立可验收、可审计的全生命周期数据保护体系。

---

## 8.3.1 数据生命周期模型

### 标准六阶段模型

数据生命周期管理（Data Lifecycle Management, DLM）将数据资产从产生到销毁划分为六个阶段，每个阶段有不同的风险暴露面与控制重点：

```
阶段1: 创建/采集 (Create/Collect)
├─ 来源：用户输入、系统生成、外部采集、第三方接入
├─ 风险：过度采集、未授权采集、合法性基础缺失
└─ 控制：数据最小化、同意管理、合法性基础验证、输入验证

阶段2: 存储 (Store)
├─ 位置：数据库、文件系统、对象存储、数据湖
├─ 风险：未加密存储、权限过宽、备份泄露
└─ 控制：静态加密、访问控制、分层存储、安全备份

阶段3: 使用 (Use)
├─ 场景：查询分析、报表生成、AI 训练、业务决策
├─ 风险：越权访问、滥用、批量导出
└─ 控制：最小权限、审计日志、脱敏、行为监控

阶段4: 共享 (Share)
├─ 方式：API、文件传输、跨境、第三方、内部协作
├─ 风险：未授权共享、跨境违规、第三方泄露
└─ 控制：传输加密、跨境审批、DLP、供应商管理

阶段5: 归档 (Archive)
├─ 目的：合规保留、历史查询、灾难恢复
├─ 风险：归档介质泄露、访问控制失效、遗忘数据
└─ 控制：冷存储加密、访问审批、保留期限、定期审查

阶段6: 销毁 (Destroy)
├─ 触发：保留期满、业务终止、用户删除请求（DSR）
├─ 风险：不完全销毁、销毁证据缺失、意外恢复
└─ 控制：不可逆销毁、多副本清除、销毁证明、审计记录
```

### 生命周期与控制矩阵

下表展示每个阶段的主要威胁与对应控制措施。责任方划分需结合组织架构确定，避免多头管理或责任真空。

| 生命周期阶段 | 主要威胁 | 核心控制 | 技术实现 | 责任方 |
|--------------|----------|----------|----------|--------|
| 创建/采集 | 过度采集、非法采集 | 数据最小化、同意管理 | 表单验证、CMP、API 限流 | 产品/研发 |
| 存储 | 未加密、权限过宽 | 加密、访问控制 | TDE、KMS、IAM | 基础设施/DBA |
| 使用 | 越权访问、滥用 | 最小权限、审计 | RBAC/ABAC、DAM、UEBA | 数据所有者 |
| 共享 | 未授权共享、跨境违规 | DLP、传输加密、审批 | DLP、TLS、跨境审批系统 | 数据保护官 |
| 归档 | 归档泄露、遗忘 | 冷存储加密、保留策略 | 对象锁定、ILM | 存储/合规 |
| 销毁 | 不完全销毁 | 不可逆销毁、证明 | 安全擦除、销毁记录 | IT/法务 |

适用边界：
- 本六阶段模型适用于结构化与非结构化数据，不适用于实时流数据（需单独设计流式数据安全架构）。
- 对象存储、数据湖场景下，"归档"与"存储"阶段边界模糊，可合并为"持久化存储"阶段，通过 ILM 策略区分热 / 温 / 冷层级。

关键约束：
- 跨阶段控制一致性：数据在不同阶段的加密密钥、访问权限、审计日志需保持关联，避免"归档后权限失效"或"备份未加密"。
- 合规保留期冲突：业务可能要求快速销毁（如用户删除请求），但法规可能要求保留（如税务记录 7 年），需在系统设计时预留"法务冻结"机制。

---

## 8.3.2 阶段一：数据创建与采集安全

### 数据最小化原则 (Data Minimization)

GDPR Art.5(1)(c) 要求个人数据"充分的、相关的，并限于处理目的所必需的范围"。数据最小化是隐私工程的起点，在表单设计、API 接口、第三方集成阶段即需执行。

实施要点：

```python
# 示例：用户注册表单数据最小化设计

class UserRegistrationForm:
    """用户注册表单 - 数据最小化设计"""

    # 必需字段（完成注册所需的最小数据集）
    REQUIRED_FIELDS = {
        'email': {
            'type': 'email',
            'purpose': '账号登录与通知',
            'legal_basis': 'contract',  # GDPR Art.6(1)(b)
            'retention': '账号存续期间'
        },
        'password': {
            'type': 'password',
            'purpose': '身份认证',
            'legal_basis': 'contract',
            'retention': '账号存续期间',
            'hashing': 'bcrypt'  # 单向 Hash，不可逆
        }
    }

    # 可选字段（增强功能，需用户明确同意）
    OPTIONAL_FIELDS = {
        'phone': {
            'type': 'phone',
            'purpose': '双因素认证、订单通知',
            'legal_basis': 'consent',  # GDPR Art.6(1)(a)
            'consent_required': True,
            'consent_text': '我同意提供手机号用于接收订单通知',
            'retention': '同意撤回后 30 日内删除'
        },
        'birth_date': {
            'type': 'date',
            'purpose': '年龄验证、生日优惠',
            'legal_basis': 'consent',
            'consent_required': True,
            'retention': '同意撤回后 30 日内删除'
        },
        'marketing_consent': {
            'type': 'boolean',
            'purpose': '营销邮件推送',
            'legal_basis': 'consent',
            'consent_required': True,
            'opt_out': True,  # 可随时撤回
            'retention': '撤回后立即停止'
        }
    }

    # 禁止采集字段（GDPR Art.9 特殊类别）
    PROHIBITED_FIELDS = [
        'race',  # 种族
        'religion',  # 宗教信仰
        'health_data',  # 健康数据
        'biometric_data',  # 生物特征（除非 KYC 必需）
        'political_opinion'  # 政治观点
    ]

    def validate_collection(self, form_data):
        """验证采集的合法性与必要性"""
        for field, value in form_data.items():
            # 检查是否禁止采集
            if field in self.PROHIBITED_FIELDS:
                raise ValueError(f"禁止采集字段: {field}")

            # 检查可选字段是否有同意
            if field in self.OPTIONAL_FIELDS:
                if not form_data.get(f'{field}_consent'):
                    raise ValueError(f"可选字段 {field} 需要用户同意")

        return True
```

常见误区：
1. 将"可选"字段设计为"默认勾选"，违反 GDPR 主动同意要求（同意需具体、明确、可撤回，不得预勾选）。
2. 采集"备用"数据（如"可能将来会用到"），违反数据最小化原则。
3. 未区分"必需"与"可选"，导致用户拒绝可选字段后无法完成核心功能。

验证方法：
- 隐私设计评审：产品设计阶段由隐私工程师审查表单字段，验证每个字段的"必要性证明"。
- 同意撤回测试：用户撤回可选字段同意后，验证系统是否在承诺时限内删除数据（如 30 天）。
- A/B 测试：对比"最小化表单"与"完整表单"的用户转化率与数据质量，平衡隐私与业务目标。

运行指标：
- 同意撤回率：监控用户撤回同意的比例，高撤回率可能表明同意文案不清晰或功能价值不足。
- 可选字段填写率：低于 30% 表明该字段对用户价值不足，考虑移除。
- 禁止字段拦截数：开发环境中拦截到的禁止字段提交次数，应为零（生产环境禁止出现）。

### 合法处理基础 (Lawful Basis)

GDPR Art.6 规定六种个人数据处理的合法基础。选择错误的合法基础会导致整个处理活动违法。

| 合法基础 | 说明 | 适用场景 | 用户权利 |
|----------|------|----------|----------|
| (a) 同意 (Consent) | 用户明确、自由给予的同意 | 营销邮件、Cookie、可选功能 | 可随时撤回 |
| (b) 合同履行 (Contract) | 履行与用户的合同所必需 | 订单处理、物流配送、账单 | 不可拒绝（合同必需） |
| (c) 法定义务 (Legal Obligation) | 遵守法律要求 | 税务记录、反洗钱（AML）、法院传票 | 不可拒绝 |
| (d) 切身利益 (Vital Interests) | 保护生命安全 | 紧急医疗、灾难救援 | 极少使用 |
| (e) 公共利益 (Public Interest) | 公共机构履行职责 | 政府服务、公共卫生 | 公共部门 |
| (f) 合法利益 (Legitimate Interest) | 控制者的合法利益，不侵犯用户权利 | 欺诈检测、网络安全、内部分析 | 需平衡测试 (LIA) |

关键约束：
- 合法基础不可叠加：一项处理活动只能基于一种合法基础，不能"既基于同意又基于合法利益"。
- 合法基础不可事后变更：初始采集基于同意，后续不能改为合法利益（除非重新评估并通知用户）。
- 合法利益需平衡测试：需证明控制者利益不超过用户的基本权利和自由（需 LIA - Legitimate Interest Assessment）。

验证方法：
- 隐私政策审查：确保每类数据处理活动在隐私政策中明确声明合法基础。
- DPIA（数据保护影响评估）：对于基于合法利益的高风险处理（如 UEBA 行为分析），需执行 DPIA 验证平衡性。
- 同意撤回流程测试：验证用户撤回同意后，系统是否停止处理并删除数据（合同履行除外）。

### 同意管理平台 (CMP - Consent Management Platform)

Cookie 同意是 GDPR 与 ePrivacy 指令的强制要求。同意需满足：具体（granular）、明确（unambiguous）、可撤回（revocable）。

```javascript
// 示例：Cookie 同意管理（符合 ePrivacy + GDPR）

class ConsentManager {
    constructor() {
        this.consentTypes = {
            'necessary': {
                name: '必要 Cookie',
                description: '网站运行所必需,无法拒绝',
                required: true,
                cookies: ['session_id', 'csrf_token', 'language']
            },
            'analytics': {
                name: '分析 Cookie',
                description: '帮助我们了解用户行为,改进服务',
                required: false,
                cookies: ['_ga', '_gid', '_gat'],
                vendor: 'Google Analytics'
            },
            'marketing': {
                name: '营销 Cookie',
                description: '用于展示个性化广告',
                required: false,
                cookies: ['_fbp', '_gcl_au'],
                vendor: 'Facebook, Google Ads'
            }
        };
    }

    // 展示同意横幅
    showConsentBanner() {
        // 检查是否已有同意记录
        if (this.hasValidConsent()) {
            return;
        }

        // 展示同意 UI
        const banner = `
        <div id="consent-banner">
            <h3>我们使用 Cookie</h3>
            <p>我们使用 Cookie 来改善您的体验。点击"接受"即表示同意。</p>
            <button onclick="consentManager.acceptAll()">接受全部</button>
            <button onclick="consentManager.showDetails()">自定义</button>
            <button onclick="consentManager.rejectOptional()">仅必要</button>
        </div>
        `;
        document.body.insertAdjacentHTML('beforeend', banner);
    }

    // 记录同意
    recordConsent(choices) {
        const consent = {
            timestamp: new Date().toISOString(),
            choices: choices,
            version: '1.0',  // 隐私政策版本
            ip: this.getUserIP(),  // 记录 IP 作为证据
            user_agent: navigator.userAgent
        };

        // 存储同意记录（12 个月有效期）
        localStorage.setItem('consent_record', JSON.stringify(consent));

        // 上传到服务器（合规审计）
        this.uploadConsentRecord(consent);

        // 根据同意加载 Cookie
        this.loadCookiesByConsent(choices);
    }

    // 允许撤回同意
    withdrawConsent() {
        localStorage.removeItem('consent_record');
        this.deleteAllOptionalCookies();
        alert('您的同意已撤回,可选 Cookie 已删除');
    }
}

const consentManager = new ConsentManager();
consentManager.showConsentBanner();
```

常见误区：
1. "关闭弹窗即同意"设计：GDPR 要求明确的同意动作（如点击"接受"），关闭弹窗或继续浏览不构成同意。
2. 拒绝按钮不明显：拒绝按钮需与接受按钮同等显眼（不得用小字或隐藏在"设置"中）。
3. Cookie 墙（Cookie Wall）：阻止用户拒绝 Cookie 后访问网站，CJEU 判决认定违法（同意需自由给予）。

验证方法：
- 浏览器插件测试：使用 Cookie Checker 验证未同意时是否仍加载非必要 Cookie。
- 同意记录审计：检查服务器日志中的同意记录，验证 IP、User-Agent、隐私政策版本是否完整记录。
- A/B 测试：对比不同同意 UI 的同意率与拒绝率，优化用户体验与合规性平衡。

运行指标：
- 同意率与拒绝率：监控不同地域用户的同意偏好（欧盟用户拒绝率通常高于其他地区）。
- 同意撤回次数：高撤回率可能表明同意文案误导或功能价值不足。
- Cookie 扫描覆盖度：定期扫描网站所有 Cookie，确保隐私政策中声明的 Cookie 列表完整。

### 第三方数据采集管理

SDK、脚本、API 集成可能导致数据泄露到第三方，需建立白名单与安全评估机制。

```python
# 第三方 SDK 白名单管理

class ThirdPartySDKGovernance:
    """第三方 SDK 治理框架"""

    # SDK 白名单（经过安全评估）
    APPROVED_SDKS = {
        'google-analytics': {
            'version': '4.0',
            'purpose': '网站分析',
            'data_collected': ['页面访问', 'IP 地址（匿名化）', '设备类型'],
            'dpa_signed': True,  # 数据处理协议已签署
            'dpia_completed': True,  # 隐私影响评估已完成
            'risk_level': 'Low',
            'approved_date': '2025-01-01',
            'review_due': '2026-01-01'
        },
        'stripe-payment': {
            'version': '3.5',
            'purpose': '支付处理',
            'data_collected': ['支付卡信息', '账单地址'],
            'pci_compliant': True,
            'dpa_signed': True,
            'risk_level': 'Medium',
            'approved_date': '2025-01-01',
            'review_due': '2025-07-01'
        }
    }

    def validate_sdk(self, sdk_name, sdk_version):
        """验证 SDK 是否在白名单且版本合规"""
        if sdk_name not in self.APPROVED_SDKS:
            raise SecurityError(f"SDK {sdk_name} 未经批准，禁止使用")

        approved = self.APPROVED_SDKS[sdk_name]
        if sdk_version != approved['version']:
            raise SecurityError(f"SDK 版本不匹配，批准版本: {approved['version']}")

        # 检查是否需要复审
        if self.is_review_overdue(approved['review_due']):
            raise SecurityError(f"SDK {sdk_name} 需要复审")

        return True

    def request_new_sdk(self, sdk_name, justification):
        """申请新 SDK"""
        # 创建安全评估工单
        ticket = {
            'sdk_name': sdk_name,
            'requestor': self.get_current_user(),
            'justification': justification,
            'security_review': 'Pending',
            'privacy_review': 'Pending',
            'dpa_negotiation': 'Pending'
        }
        return self.create_jira_ticket(ticket)
```

关键约束：
- SDK 版本锁定：批准特定版本的 SDK，升级需重新安全评估（避免供应链攻击，如 npm 投毒）。
- DPA（数据处理协议）强制要求：GDPR Art.28 要求与数据处理者签署 DPA，明确双方责任。
- 复审周期：高风险 SDK（如支付、分析）每 6-12 个月复审，低风险 SDK 每 12-24 个月。

验证方法：
- 代码扫描：使用 SCA（Software Composition Analysis）工具扫描代码库，识别未批准的第三方 SDK。
- 网络流量分析：监控生产环境网络流量，识别未声明的第三方数据传输（如广告 SDK 偷偷上传数据）。
- DPA 合规审计：定期审计已签署 DPA 的执行情况，验证供应商是否遵守约定（如数据删除承诺）。

运行指标：
- 白名单覆盖率：生产环境中使用的第三方 SDK 在白名单中的占比（目标 100%）。
- 未批准 SDK 拦截次数：CI/CD 流水线拦截的未批准 SDK 提交次数。
- DPA 签署率：与所有数据处理者签署 DPA 的比例（GDPR 强制要求 100%）。

---

## 8.3.3 阶段二：数据存储安全

### 分层存储策略

根据数据分类（Public/Internal/Confidential/Restricted）实施差异化存储控制。过度保护会增加成本与延迟，保护不足会导致合规风险。

| 分类 | 存储方式 | 加密要求 | 访问控制 | 备份策略 |
|------|----------|----------|----------|----------|
| Restricted | 独立加密数据库<br>HSM 保护密钥 | • 列级加密 (AES-256)<br>• 传输 TLS 1.3<br>• 密钥轮换 90 天 | • MFA + PAM<br>• 最小权限<br>• 双人审批 | • 加密备份<br>• 异地容灾<br>• 备份加密密钥分离 |
| Confidential | 加密数据库<br>KMS 管理密钥 | • 透明数据加密 (TDE)<br>• 传输 TLS 1.2+ | • RBAC<br>• MFA（管理员） | • 加密备份<br>• 本地+云 |
| Internal | 标准数据库 | • 传输 TLS<br>• 可选静态加密 | • RBAC<br>• 基础认证 | • 标准备份 |
| Public | CDN/对象存储 | • 完整性校验 (Hash) | • 公开读取<br>• 版本控制 | • 版本归档 |

适用边界：
- 本分层策略适用于云原生架构（AWS/Azure/GCP），传统数据中心需根据硬件能力调整（如无 HSM 时使用软件加密）。
- 混合数据（如包含少量敏感字段的 Internal 表）按最高敏感度分类（如一个 Internal 表中有 1 列 Confidential，整表按 Confidential 处理）。

关键约束：
- 列级加密性能影响：加密列无法使用数据库索引，查询性能下降 10-100 倍（需在应用层缓存或使用可搜索加密）。
- 密钥轮换停机时间：密钥轮换过程中需重新加密数据，大表可能需数小时（需验证在线轮换能力）。
- 备份加密密钥管理：备份加密密钥需与生产密钥分离存储，否则攻击者窃取备份后可直接解密。

验证方法：
- 加密有效性测试：导出加密数据库文件，验证未经密钥无法读取（防止"假加密"配置错误）。
- 权限越界测试：使用低权限账号尝试访问 Restricted 数据，验证访问控制有效性。
- 备份恢复演练：定期（每季度）执行备份恢复，验证 RTO（恢复时间目标）与 RPO（恢复点目标）。

运行指标：
- 加密覆盖率：Restricted/Confidential 数据加密存储的比例（目标 100%）。
- 密钥轮换合规率：密钥轮换按计划执行的比例（如 90 天轮换一次）。
- 备份恢复成功率：备份恢复演练的成功率（目标 > 95%）。

### 数据库安全配置基线

以下为 PostgreSQL 安全配置示例，其他数据库（MySQL/Oracle/SQL Server）需根据文档调整。

```sql
-- PostgreSQL 安全配置示例

-- 1. 启用透明数据加密（TDE）
ALTER SYSTEM SET encryption = 'on';

-- 2. 配置 SSL/TLS 连接
ALTER SYSTEM SET ssl = 'on';
ALTER SYSTEM SET ssl_cert_file = '/path/to/server.crt';
ALTER SYSTEM SET ssl_key_file = '/path/to/server.key';
ALTER SYSTEM SET ssl_min_protocol_version = 'TLSv1.3';

-- 3. 启用审计日志
ALTER SYSTEM SET log_connections = 'on';
ALTER SYSTEM SET log_disconnections = 'on';
ALTER SYSTEM SET log_statement = 'ddl';  -- 记录所有 DDL 操作
ALTER SYSTEM SET log_line_prefix = '%t [%p]: user=%u,db=%d,app=%a,client=%h ';

-- 4. 配置密码策略
ALTER SYSTEM SET password_encryption = 'scram-sha-256';

-- 5. 限制超级用户连接
ALTER SYSTEM SET max_connections = 100;
CREATE ROLE app_user WITH LOGIN PASSWORD 'strong_password' NOSUPERUSER;

-- 6. 行级安全策略（RLS）示例
CREATE TABLE customer_data (
    id SERIAL PRIMARY KEY,
    user_id INT,
    email VARCHAR(100),
    credit_card VARCHAR(19),
    created_at TIMESTAMP DEFAULT NOW()
);

-- 启用 RLS
ALTER TABLE customer_data ENABLE ROW LEVEL SECURITY;

-- 策略：用户只能访问自己的数据
CREATE POLICY user_isolation_policy ON customer_data
    FOR SELECT
    USING (user_id = current_setting('app.current_user_id')::INT);

-- 策略：管理员可访问所有数据（需审计）
CREATE POLICY admin_access_policy ON customer_data
    FOR ALL
    TO admin_role
    USING (true)
    WITH CHECK (true);

-- 7. 列级加密（应用层实现）
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 插入时加密
INSERT INTO customer_data (user_id, email, credit_card)
VALUES (
    123,
    'user@example.com',
    pgp_sym_encrypt('4111111111111111', 'encryption_key')
);

-- 查询时解密（仅授权用户）
SELECT
    id,
    user_id,
    email,
    pgp_sym_decrypt(credit_card::bytea, 'encryption_key') AS credit_card
FROM customer_data
WHERE user_id = 123;
```

常见误区：
1. TDE 与列级加密混淆：TDE 保护磁盘文件（防物理盗窃），列级加密保护内存与日志（防 DBA 越权），两者解决不同威胁。
2. 审计日志未发送到 SIEM：审计日志存储在数据库本地，攻击者可删除日志掩盖痕迹（需实时发送到独立 SIEM）。
3. 默认账号未禁用：postgres/root 等默认超级用户未禁用或弱密码，成为攻击入口。

验证方法：
- 配置合规扫描：使用 CIS Benchmark 或云原生 CSPM 工具扫描数据库配置，识别偏离基线的配置项。
- 渗透测试：委托红队或第三方尝试窃取数据库文件、提权、绕过 RLS，验证防护有效性。
- 审计日志完整性校验：定期（每日）校验审计日志 Hash，确保未被篡改。

运行指标：
- 配置合规率：数据库实例符合安全基线的比例（目标 100%）。
- 审计日志发送延迟：审计日志从数据库发送到 SIEM 的平均延迟（目标 < 5 分钟）。
- RLS 策略覆盖率：启用 RLS 的敏感表占比（目标 Confidential 及以上 100%）。

### 云存储安全配置

云对象存储（如 AWS S3）因配置错误导致数据泄露的案例频发，需建立强制加密与公共访问阻止策略。

```python
# AWS S3 安全配置示例

import boto3
import json

s3 = boto3.client('s3')
kms = boto3.client('kms')

# 1. 创建加密的 S3 存储桶
def create_secure_bucket(bucket_name, classification):
    """根据数据分类创建安全存储桶"""

    # 创建存储桶
    s3.create_bucket(Bucket=bucket_name)

    # 配置 1：默认加密（SSE-KMS）
    s3.put_bucket_encryption(
        Bucket=bucket_name,
        ServerSideEncryptionConfiguration={
            'Rules': [{
                'ApplyServerSideEncryptionByDefault': {
                    'SSEAlgorithm': 'aws:kms',
                    'KMSMasterKeyID': 'arn:aws:kms:us-east-1:123456789:key/xxx'
                },
                'BucketKeyEnabled': True
            }]
        }
    )

    # 配置 2：阻止公共访问
    s3.put_public_access_block(
        Bucket=bucket_name,
        PublicAccessBlockConfiguration={
            'BlockPublicAcls': True,
            'IgnorePublicAcls': True,
            'BlockPublicPolicy': True,
            'RestrictPublicBuckets': True
        }
    )

    # 配置 3：启用版本控制（防误删）
    s3.put_bucket_versioning(
        Bucket=bucket_name,
        VersioningConfiguration={'Status': 'Enabled'}
    )

    # 配置 4：启用访问日志
    s3.put_bucket_logging(
        Bucket=bucket_name,
        BucketLoggingStatus={
            'LoggingEnabled': {
                'TargetBucket': 'audit-logs-bucket',
                'TargetPrefix': f'{bucket_name}/'
            }
        }
    )

    # 配置 5：配置生命周期策略（自动归档 / 删除）
    if classification == 'Confidential':
        lifecycle_policy = {
            'Rules': [
                {
                    'Id': 'Archive old data',
                    'Status': 'Enabled',
                    'Transitions': [{
                        'Days': 90,
                        'StorageClass': 'GLACIER'  # 90 天后归档到冷存储
                    }],
                    'NoncurrentVersionExpiration': {'NoncurrentDays': 30}
                }
            ]
        }
        s3.put_bucket_lifecycle_configuration(
            Bucket=bucket_name,
            LifecycleConfiguration=lifecycle_policy
        )

    # 配置 6：设置存储桶策略（最小权限）
    bucket_policy = {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Sid": "DenyUnencryptedObjectUploads",
                "Effect": "Deny",
                "Principal": "*",
                "Action": "s3:PutObject",
                "Resource": f"arn:aws:s3:::{bucket_name}/*",
                "Condition": {
                    "StringNotEquals": {
                        "s3:x-amz-server-side-encryption": "aws:kms"
                    }
                }
            },
            {
                "Sid": "DenyInsecureTransport",
                "Effect": "Deny",
                "Principal": "*",
                "Action": "s3:*",
                "Resource": f"arn:aws:s3:::{bucket_name}/*",
                "Condition": {
                    "Bool": {"aws:SecureTransport": "false"}
                }
            }
        ]
    }
    s3.put_bucket_policy(
        Bucket=bucket_name,
        Policy=json.dumps(bucket_policy)
    )

    # 配置 7：启用对象锁定（Restricted 数据，防删除）
    if classification == 'Restricted':
        s3.put_object_lock_configuration(
            Bucket=bucket_name,
            ObjectLockConfiguration={
                'ObjectLockEnabled': 'Enabled',
                'Rule': {
                    'DefaultRetention': {
                        'Mode': 'GOVERNANCE',  # 或 COMPLIANCE
                        'Days': 2555  # 7 年保留(合规要求)
                    }
                }
            }
        )

    return f"Secure bucket {bucket_name} created successfully"

# 使用示例
create_secure_bucket('customer-pii-data', 'Restricted')
```

关键约束：
- 对象锁定不可逆：COMPLIANCE 模式下，即使 AWS 账号 root 用户也无法删除对象，需谨慎使用（适用于审计日志、财务记录）。
- KMS 密钥跨区域限制：KMS 密钥绑定特定区域，跨区域复制需单独配置密钥。
- 版本控制成本：启用版本控制后，删除对象不会释放存储空间（仅添加删除标记），需配置生命周期策略清理旧版本。

验证方法：
- 公共访问扫描：使用 AWS Access Analyzer 或第三方工具（如 Prowler）扫描公共可访问的 S3 桶。
- 加密合规检查：遍历所有 S3 桶，验证是否启用默认加密与强制加密策略。
- 对象锁定测试：尝试删除已锁定对象，验证保护有效性。

运行指标：
- 公共桶数量：公共可访问的 S3 桶数量（目标为 0，除非业务需要如静态网站托管）。
- 加密覆盖率：启用加密的 S3 桶占比（目标 100%）。
- 版本控制覆盖率：Confidential 及以上数据启用版本控制的比例（目标 100%）。

### 安全备份策略

勒索软件攻击中，攻击者会加密生产数据并删除备份。3-2-1-1-0 备份原则提供多层冗余。

**3-2-1-1-0 备份原则**：
- **3** 份副本（1 份生产 + 2 份备份）
- **2** 种存储介质（磁盘 + 磁带 / 云）
- **1** 份异地存储
- **1** 份离线 / 不可变备份（防勒索软件）
- **0** 错误（定期恢复演练验证）

```yaml
# 备份策略配置示例

backup_policy:
  production_db:
    classification: Restricted
    backup_frequency:
      full: Daily 2:00 AM
      incremental: Every 6 hours
      transaction_log: Every 15 minutes

    retention:
      daily: 30 days
      weekly: 12 weeks
      monthly: 7 years  # 合规要求

    encryption:
      algorithm: AES-256-GCM
      key_source: AWS KMS
      key_rotation: 90 days

    storage_locations:
      primary: AWS S3 Standard (us-east-1)
      secondary: AWS S3 Glacier (us-west-2)
      tertiary: On-premise tape (offline, air-gapped)

    access_control:
      backup_operator: Read-only
      restore_approval: Dual authorization required
      audit: All access logged to SIEM

    recovery_objectives:
      RTO: 4 hours  # 恢复时间目标
      RPO: 15 minutes  # 恢复点目标

    testing:
      restore_drill: Quarterly
      full_recovery_test: Annually
```

常见误区：
1. 备份与生产在同一存储：勒索软件加密生产数据后，同时加密同一存储上的备份（需异地或离线备份）。
2. 备份未加密：备份介质（如磁带）被盗后，攻击者直接读取敏感数据（需加密备份）。
3. 备份未测试恢复：备份成功但恢复失败（如备份损坏、密钥丢失），定期演练验证恢复能力。

验证方法：
- 备份完整性校验：每次备份后计算 Hash，定期（每周）验证 Hash 未变化。
- 恢复演练：每季度执行备份恢复到独立环境，验证数据完整性与 RTO/RPO。
- 勒索软件模拟：红队模拟勒索软件攻击，验证离线备份是否可被加密或删除。

运行指标：
- 备份成功率：备份任务成功执行的比例（目标 > 99%）。
- 恢复演练成功率：恢复演练中成功恢复且验证通过的比例（目标 > 95%）。
- 离线备份更新频率：离线备份（如磁带）的更新频率（建议每周或每月）。

---

## 8.3.4 阶段三：数据传输安全

### 传输加密协议选择

传输加密保护数据在网络中的机密性与完整性。协议选择需平衡安全性与性能。

| 场景 | 推荐协议 | 配置要点 | 安全级别 |
|------|----------|----------|----------|
| **Web 应用(HTTPS)** | TLS 1.3 | • 禁用 TLS 1.0/1.1<br>• 使用强密码套件<br>• 启用 HSTS | 高 |
| **数据库连接** | TLS 1.2+ / mTLS | • 双向认证<br>• 证书 pinning | 高 |
| **文件传输** | SFTP / FTPS | • 禁用 FTP 明文<br>• 密钥认证 | 中 |
| **API 调用** | HTTPS + mTLS | • API 密钥加密传输<br>• JWT 签名 | 高 |
| **内网通信** | IPSec / WireGuard | • 站点到站点 VPN<br>• 零信任网络 | 高 |
| **邮件** | TLS + S/MIME | • 强制 TLS<br>• 端到端加密 | 中 |

适用边界：
- TLS 1.3 适用于公网通信，内网可使用 IPSec（性能更好，但配置复杂）。
- mTLS（双向认证）适用于高敏感 API（如支付、数据导出），增加客户端证书管理成本。

关键约束：
- TLS 握手延迟：TLS 1.3 握手需 1-RTT，TLS 1.2 需 2-RTT（高延迟网络如跨洋需考虑 0-RTT 会话恢复，但有重放攻击风险）。
- 证书管理复杂度：mTLS 需为每个客户端颁发证书，证书轮换、吊销需自动化管理（如使用 ACME 协议）。
- 性能开销：TLS 加密消耗 CPU 资源，高流量场景需硬件加速（如 SSL 卸载卡）或使用 ChaCha20（比 AES 在无硬件加速 CPU 上快）。

验证方法：
- SSL Labs 测试：使用 SSL Labs 扫描 HTTPS 端点，验证协议版本、密码套件、证书链。
- mTLS 客户端测试：使用无效证书或过期证书尝试连接，验证服务端拒绝连接。
- 中间人攻击模拟：使用 mitmproxy 或 Burp Suite 尝试拦截流量，验证证书 pinning 有效性。

运行指标：
- TLS 1.3 覆盖率：使用 TLS 1.3 的 HTTPS 连接占比（目标 > 90%）。
- 弱密码套件使用率：使用弱密码套件（如 3DES、RC4）的连接占比（目标 0%）。
- 证书过期事件：证书过期导致服务中断的次数（目标 0，需自动化证书续期）。

### TLS 1.3 最佳实践

TLS 1.3 移除了不安全的密码套件（如 RSA 密钥交换），强制前向保密（Forward Secrecy）。

```nginx
# Nginx TLS 1.3 安全配置

server {
    listen 443 ssl http2;
    server_name secure.example.com;

    # 1. 证书配置
    ssl_certificate /path/to/fullchain.pem;
    ssl_certificate_key /path/to/privkey.pem;

    # 2. 仅允许 TLS 1.2 和 1.3
    ssl_protocols TLSv1.2 TLSv1.3;

    # 3. 配置强密码套件(优先 TLS 1.3)
    ssl_ciphers 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers on;

    # 4. 启用 OCSP Stapling（证书状态检查）
    ssl_stapling on;
    ssl_stapling_verify on;
    ssl_trusted_certificate /path/to/chain.pem;

    # 5. 启用 HSTS（强制 HTTPS）
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    # 6. 其他安全头
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # 7. 禁用不安全的 HTTP 方法
    if ($request_method !~ ^(GET|POST|PUT|DELETE|OPTIONS)$ ) {
        return 405;
    }

    location / {
        proxy_pass http://backend;
        proxy_set_header X-Forwarded-Proto https;
    }
}
```

常见误区：
1. 未禁用 TLS 1.0/1.1：PCI DSS 4.0 要求禁用 TLS 1.0/1.1，但许多遗留系统仍启用。
2. HSTS 未包含 subdomains：子域名未强制 HTTPS，攻击者可通过子域名中间人攻击（需 includeSubDomains）。
3. 证书链不完整：缺少中间证书，部分客户端（如旧版 Android）无法验证证书链。

验证方法：
- SSL Labs 扫描：A+ 评级要求 TLS 1.3、强密码套件、HSTS、OCSP Stapling 全部配置正确。
- 旧客户端兼容性测试：使用旧版浏览器（如 IE 11）测试连接，验证是否正确拒绝或降级到 TLS 1.2。
- HSTS 预加载测试：提交域名到 HSTS Preload List，验证所有子域名强制 HTTPS。

运行指标：
- SSL Labs 评级分布：A+ 评级的 HTTPS 端点占比（目标 > 95%）。
- HSTS 覆盖率：启用 HSTS 的 HTTPS 端点占比（目标 100%）。
- OCSP Stapling 成功率：OCSP Stapling 响应成功的比例（目标 > 99%）。

### 跨境数据传输安全

GDPR Chapter V、PIPL 第 38-43 条对跨境数据传输有严格限制。技术控制需与合规机制配合。

```python
# 跨境数据传输审批与加密流程

class CrossBorderDataTransfer:
    """跨境数据传输管理"""

    # 数据出境目标国家风险评级
    COUNTRY_RISK = {
        'US': {'risk': 'Medium', 'mechanism': 'DPF'},
        'EU': {'risk': 'Low', 'mechanism': 'SCC'},
        'UK': {'risk': 'Low', 'mechanism': 'UK-SCC'},
        'SG': {'risk': 'Low', 'mechanism': 'APEC-CBPR'},
        'CN': {'risk': 'High', 'mechanism': 'Security-Assessment'}
    }

    def request_transfer(self, data_asset, target_country, purpose):
        """申请跨境数据传输"""

        # 步骤 1：数据分类检查
        classification = self.get_classification(data_asset)
        if classification == 'Restricted':
            raise ValueError("Restricted 数据禁止跨境传输")

        # 步骤 2：目标国家风险评估
        country_risk = self.COUNTRY_RISK.get(target_country, {'risk': 'Unknown'})
        if country_risk['risk'] == 'Unknown':
            raise ValueError(f"未评估国家: {target_country}, 需先完成 TIA")

        # 步骤 3：创建 TIA（Transfer Impact Assessment）
        tia = self.conduct_tia(data_asset, target_country, purpose)

        # 步骤 4：选择合规机制
        mechanism = country_risk['mechanism']
        compliance_docs = self.prepare_compliance_docs(mechanism)

        # 步骤 5：GRC 团队审批（安全风险管理委员会）
        approval = self.request_grc_approval(tia, compliance_docs)
        if not approval['approved']:
            raise ValueError(f"审批被拒: {approval['reason']}")

        # 步骤 6：实施技术控制
        self.apply_technical_controls(data_asset, target_country)

        # 步骤 7：记录出境档案
        self.record_transfer_log(data_asset, target_country, approval)

        return {
            'transfer_id': approval['id'],
            'status': 'Approved',
            'valid_until': approval['expiry_date'],
            'mechanism': mechanism
        }

    def apply_technical_controls(self, data_asset, target_country):
        """应用技术控制"""

        # 控制 1：传输加密（TLS 1.3）
        self.enforce_tls_encryption(data_asset)

        # 控制 2：数据脱敏（如适用）
        if self.requires_pseudonymization(data_asset):
            data_asset = self.pseudonymize(data_asset)

        # 控制 3：传输日志
        self.log_transfer(data_asset, target_country)

        # 控制 4：DLP 监控
        self.enable_dlp_monitoring(data_asset)

        # 控制 5：加密通道（mTLS）
        self.establish_mtls_tunnel(target_country)

        return data_asset
```

关键约束：
- Schrems II 判决影响：EU-US 数据传输需评估美国政府访问风险，SCC 不足以合规（需补充措施如假名化、加密）。
- PIPL 安全评估周期：中国关键信息基础设施运营者（CIIO）数据出境需通过安全评估，审批周期可能数月。
- TIA 执行成本：每次新的跨境传输需执行 TIA，评估数据接收国的法律环境、政府访问权力，需法务与技术协作。

验证方法：
- 跨境传输审计：定期（每季度）审计所有跨境数据传输，验证是否有未批准的传输。
- DLP 规则测试：配置 DLP 规则拦截未批准的跨境传输，红队测试绕过路径（如加密压缩包、隐蔽通道）。
- TIA 合规审查：委托法务或第三方审查 TIA 文档，验证是否充分评估目标国风险。

运行指标：
- 跨境传输合规率：经过审批的跨境传输占比（目标 100%）。
- TIA 执行周期：从申请到批准的平均周期（目标 < 30 天）。
- DLP 拦截成功率：DLP 成功拦截未批准跨境传输的比例。

---

## 8.3.5 阶段四：数据使用安全

### 最小权限访问（Least Privilege Access）

RBAC（基于角色）适用于权限稳定场景，ABAC（基于属性）适用于动态授权场景（如临时访问、跨部门协作）。

```python
# 基于属性的访问控制（ABAC）示例

class ABACEngine:
    """属性基础访问控制引擎"""

    def evaluate_access(self, subject, resource, action, environment):
        """评估访问请求"""

        # 主体属性（Subject Attributes）
        user_attrs = {
            'user_id': subject.id,
            'role': subject.role,
            'department': subject.department,
            'clearance_level': subject.clearance_level,
            'employment_type': subject.employment_type,  # Full-time/Contractor
            'mfa_verified': subject.mfa_verified
        }

        # 资源属性（Resource Attributes）
        data_attrs = {
            'classification': resource.classification,
            'owner_department': resource.owner_department,
            'compliance_tags': resource.compliance_tags,
            'sensitivity_score': resource.sensitivity_score
        }

        # 环境属性（Environment Attributes）
        env_attrs = {
            'time': environment.current_time,
            'ip_address': environment.ip,
            'device_trusted': environment.device_trusted,
            'location': environment.geo_location
        }

        # 策略规则评估
        rules = [
            self.rule_clearance_level(user_attrs, data_attrs),
            self.rule_department_match(user_attrs, data_attrs),
            self.rule_mfa_required(user_attrs, data_attrs),
            self.rule_time_restriction(user_attrs, env_attrs),
            self.rule_location_restriction(user_attrs, env_attrs),
            self.rule_contractor_limit(user_attrs, data_attrs)
        ]

        # 所有规则必须通过
        if all(rules):
            self.log_access_granted(subject, resource, action)
            return {'decision': 'Allow', 'rules_passed': len(rules)}
        else:
            failed_rules = [i for i, r in enumerate(rules) if not r]
            self.log_access_denied(subject, resource, action, failed_rules)
            return {'decision': 'Deny', 'failed_rules': failed_rules}

    def rule_clearance_level(self, user, data):
        """规则：用户 clearance 必须 >= 数据 sensitivity"""
        clearance_map = {'Public': 0, 'Internal': 1, 'Confidential': 2, 'Restricted': 3}
        return clearance_map[user['clearance_level']] >= clearance_map[data['classification']]

    def rule_department_match(self, user, data):
        """规则：Restricted 数据仅限所属部门访问"""
        if data['classification'] == 'Restricted':
            return user['department'] == data['owner_department']
        return True

    def rule_mfa_required(self, user, data):
        """规则：Confidential 及以上需 MFA"""
        if data['classification'] in ['Confidential', 'Restricted']:
            return user['mfa_verified']
        return True

    def rule_contractor_limit(self, user, data):
        """规则：外包人员禁止访问 Restricted"""
        if user['employment_type'] == 'Contractor':
            return data['classification'] != 'Restricted'
        return True
```

常见误区：
1. RBAC 角色爆炸：为每个场景创建新角色，导致角色数量失控（如"财务只读""财务编辑""财务导出"等，应合并为"财务"角色，通过权限细化）。
2. 职责分离未实施：同一用户同时拥有"创建"与"批准"权限，绕过审批流程（需 SoD - Segregation of Duties）。
3. 临时权限未回收：授予临时访问权限后未自动回收，导致权限蔓延（需设置过期时间）。

验证方法：
- 权限矩阵审计：定期（每季度）导出用户-角色-权限矩阵，识别过度授权（如普通员工拥有管理员权限）。
- SoD 冲突检测：使用 IGA（Identity Governance & Administration）工具检测职责分离冲突。
- 权限回收测试：模拟员工离职或转岗，验证权限是否在 24 小时内回收。

运行指标：
- 过度授权用户数：拥有超过岗位需要权限的用户数量。
- MFA 覆盖率：Confidential 及以上数据访问启用 MFA 的比例（目标 100%）。
- 临时权限过期率：临时权限按时回收的比例（目标 > 95%）。

### 数据脱敏技术

数据脱敏在不影响业务功能的前提下，降低数据暴露风险。选择脱敏方法需平衡隐私保护与数据可用性。

| 脱敏技术 | 说明 | 适用场景 | 可逆性 | 示例 |
|----------|------|----------|--------|------|
| **静态脱敏** | 生成假数据替换真实数据 | 测试环境、数据分析 | 不可逆 | 张三 → 用户 A |
| **动态脱敏** | 查询时实时脱敏 | 生产查询、BI 报表 | 可逆（授权用户） | 138****8000 |
| **代币化（Tokenization）** | 用随机 token 替换 | 支付、CRM | 可逆（通过 vault） | 4111-1111-1111-1111 → TOK_ABC123 |
| **假名化（Pseudonymization）** | 用假名替换，保留关联 | GDPR 合规、分析 | 可逆（有密钥） | user_123 → pseudo_789 |
| **泛化（Generalization）** | 降低数据粒度 | 统计分析 | 不可逆 | 1990-05-15 → 1990 年代 |
| **K-匿名化** | 确保 k 个人无法区分 | 数据发布 | 不可逆 | - |

适用边界：
- 动态脱敏适用于查询频率低、性能要求不高的场景（如 BI 报表），高频查询需静态脱敏或缓存。
- 代币化需维护 token vault，vault 成为单点故障与性能瓶颈（需高可用部署）。
- K-匿名化适用于结构化数据发布，非结构化数据（如文本）难以应用。

关键约束：
- 动态脱敏性能开销：查询时实时脱敏增加延迟（需在数据库层或应用层优化，如使用视图）。
- 假名化密钥管理：假名化密钥泄露后，假名可还原为真实身份（需密钥与数据分离存储）。
- 泛化数据可用性损失：过度泛化导致数据失去分析价值（如年龄 30 泛化为 18-65，无法区分年轻与老年用户）。

验证方法：
- 脱敏有效性测试：使用脱敏后的数据尝试还原真实身份，验证不可逆脱敏方法的有效性。
- 数据可用性评估：使用脱敏数据执行业务查询，验证查询结果准确性（如统计分析误差 < 5%）。
- 性能基准测试：对比脱敏前后查询性能，验证动态脱敏延迟是否在可接受范围（如 < 100ms）。

运行指标：
- 脱敏覆盖率：生产环境敏感字段动态脱敏覆盖比例（目标 Confidential 及以上 100%）。
- 测试环境真实数据占比：测试环境中包含真实敏感数据的比例（目标 0%）。
- 脱敏查询性能：动态脱敏查询的 P95 延迟（目标 < 业务 SLA）。

---

## 8.3.6 阶段五：数据归档安全

### 归档策略设计

归档平衡合规保留要求与存储成本。过度归档增加成本，归档不足违反合规要求（如 SOX 要求财务记录保留 7 年）。

```yaml
# 数据归档策略（Information Lifecycle Management - ILM）

ilm_policy:
  financial_records:
    classification: Confidential
    retention: 7 years  # SOX/税务要求

    lifecycle:
      - 阶段: Hot Storage
        duration: 1 year
        storage_tier: SSD (Production DB)
        access_frequency: High
        cost_per_gb: $0.10

      - 阶段: Warm Storage
        duration: 2 years
        storage_tier: HDD (Archive DB)
        access_frequency: Medium
        cost_per_gb: $0.03

      - 阶段: Cold Storage
        duration: 4 years
        storage_tier: Glacier / Tape
        access_frequency: Low
        retrieval_time: Hours to days
        cost_per_gb: $0.004

      - 阶段: Deletion
        trigger: 7 years + 30 days grace period
        method: Secure erase (DoD 5220.22-M)
        verification: Deletion certificate required

    encryption:
      at_rest: AES-256
      key_rotation: Annual (for archived data)

    access_control:
      hot: RBAC (authorized users)
      warm: Approval required
      cold: Dual authorization + audit

    compliance:
      sox: true
      gdpr_retention: false  # 非个人数据
      backup: Separate retention (7 years)
```

适用边界：
- 本 ILM 策略适用于云对象存储（如 AWS S3 Glacier），传统数据库归档需单独设计（如 Oracle Partitioning）。
- 混合保留期数据（如同一表中部分行需保留 7 年，部分行需保留 1 年）需应用层实现分区或分表。

关键约束：
- 冷存储检索延迟：Glacier Deep Archive 检索需 12-48 小时，紧急合规审计时无法及时提供数据（需评估业务容忍度）。
- 归档成本突增：从冷存储批量检索数据产生高额费用（如 Glacier 检索费 + 数据传输费），需在 ILM 策略中预算。
- GDPR 保留期限制：个人数据不得超过必要期限保留，财务记录 7 年与 GDPR"数据最小化"冲突需法律依据（如税法要求）。

验证方法：
- ILM 策略合规审计：定期（每年）审计归档数据保留期，验证是否符合法规要求（如 SOX/GDPR）。
- 冷存储检索测试：模拟审计请求，验证冷存储数据检索时间是否符合 SLA（如 24 小时内提供）。
- 成本优化分析：对比不同存储层级成本，优化 ILM 策略（如延长 Hot Storage 时间降低检索频率）。

运行指标：
- 归档自动化率：按 ILM 策略自动归档的数据占比（目标 > 90%，避免手动操作）。
- 冷存储检索次数：每月冷存储检索次数（高频检索表明 ILM 策略需优化）。
- 归档成本占比：归档存储成本占总存储成本的比例（目标 < 30%）。

### 冷存储访问控制

冷存储数据访问频率低，但往往包含历史敏感数据（如离职员工记录），需严格审批。

```python
# 冷存储数据访问审批流程

class ColdStorageAccessControl:
    """冷存储访问控制"""

    def request_cold_data_access(self, requester, data_asset_id, justification):
        """申请访问归档数据"""

        # 步骤 1：验证申请人身份
        if not self.verify_requester_identity(requester):
            raise SecurityError("身份验证失败")

        # 步骤 2：检查数据资产是否存在
        asset = self.get_data_asset(data_asset_id)
        if asset['storage_tier'] != 'Cold':
            raise ValueError("该资产不在冷存储中")

        # 步骤 3：创建访问申请
        request = {
            'request_id': self.generate_id(),
            'requester': requester.id,
            'asset_id': data_asset_id,
            'justification': justification,
            'requested_at': datetime.now(),
            'status': 'Pending'
        }

        # 步骤 4：自动风险评估
        risk_score = self.assess_risk(requester, asset)
        if risk_score > 70:
            request['approval_required'] = 'Dual'  # 双重审批
        else:
            request['approval_required'] = 'Single'

        # 步骤 5：发送审批通知
        self.notify_approvers(request)

        # 步骤 6：记录审计日志
        self.audit_log(request)

        return request

    def approve_access(self, request_id, approver):
        """审批访问请求"""

        request = self.get_request(request_id)

        # 验证审批人权限
        if not self.is_authorized_approver(approver, request):
            raise SecurityError("无审批权限")

        # 更新状态
        request['status'] = 'Approved'
        request['approved_by'] = approver.id
        request['approved_at'] = datetime.now()

        # 执行数据恢复（从 Glacier 恢复到临时存储）
        self.initiate_data_restoration(request['asset_id'])

        # 设置访问过期时间（24 小时）
        request['access_expires_at'] = datetime.now() + timedelta(hours=24)

        # 通知申请人
        self.notify_requester(request)

        return request
```

常见误区：
1. 归档后访问控制失效：数据归档到冷存储后，原有访问控制策略未迁移，导致任意用户可访问（需在归档时保留或加强访问控制）。
2. 审批流程绕过：允许申请人自行恢复冷存储数据，绕过审批（需强制审批工单）。
3. 访问权限无过期：批准访问后未设置过期时间，导致长期访问权限（需自动回收）。

验证方法：
- 审批流程测试：使用低权限账号尝试访问冷存储数据，验证审批流程强制执行。
- 访问过期测试：批准访问 24 小时后，验证访问权限是否自动回收。
- 审计日志完整性：检查所有冷存储访问是否记录在审计日志（包括申请人、审批人、访问时间、数据资产）。

运行指标：
- 冷存储访问审批周期：从申请到批准的平均周期（目标 < 24 小时）。
- 访问权限过期回收率：访问权限到期后自动回收的比例（目标 100%）。
- 未批准访问尝试数：未经批准尝试访问冷存储的次数（目标 0）。

---

## 8.3.7 阶段六：数据销毁安全

### 数据销毁方法

数据销毁需确保不可恢复。不同介质需使用不同销毁方法，物理销毁最可靠但成本高。

| 介质类型 | 销毁方法 | 标准 | 验证方式 |
|----------|----------|------|----------|
| **HDD 硬盘** | • 多次覆写(7 遍)<br>• 消磁(Degaussing)<br>• 物理销毁(破碎) | DoD 5220.22-M<br>NIST 800-88 | 销毁证书<br>照片/视频记录 |
| **SSD 固态盘** | • 加密擦除(Crypto Erase)<br>• 物理销毁 | NIST 800-88 Rev.1 | 固件确认<br>物理销毁证明 |
| **云存储** | • 删除对象<br>• 删除密钥<br>• 删除快照/备份 | CSA Guidelines | API 删除确认<br>日志记录 |
| **数据库** | • TRUNCATE TABLE<br>• DROP TABLE<br>• 覆写存储空间 | - | SQL 日志<br>VACUUM FULL |
| **纸质文档** | • 碎纸机(P-4/P-5 级)<br>• 焚烧 | DIN 66399 | 销毁批次记录<br>重量记录 |
| **备份磁带** | • 消磁<br>• 物理销毁 | - | 销毁清单<br>照片 |

适用边界：
- DoD 5220.22-M 多次覆写适用于 HDD，SSD 因磨损均衡（Wear Leveling）机制，覆写无法保证数据完全销毁（需加密擦除或物理销毁）。
- 云存储删除需同时删除所有版本、快照、跨区域复制，否则数据仍可恢复。

关键约束：
- SSD 加密擦除依赖固件：部分 SSD 固件实现有缺陷，加密擦除后数据仍可恢复（需验证固件版本或使用物理销毁）。
- 云存储删除不可逆：云服务商（如 AWS）删除对象后，通常无法恢复（需确认删除前备份）。
- 纸质文档销毁证明：P-5 级碎纸（颗粒 < 30mm²）符合 GDPR 要求，P-4 级（颗粒 < 160mm²）可能不足。

验证方法：
- 销毁后恢复测试：使用数据恢复工具（如 TestDisk、PhotoRec）尝试恢复已销毁数据，验证不可恢复。
- 第三方销毁审计：委托第三方审计机构现场监督硬盘物理销毁，提供销毁证书。
- 云对象删除验证：删除后使用 API 查询对象是否存在，检查所有版本与快照是否清除。

运行指标：
- 销毁证明完整率：所有 Restricted/Confidential 数据销毁后生成销毁证明的比例（目标 100%）。
- 销毁延迟：从触发销毁到完成销毁的平均时长（GDPR DSR 要求 30 天内删除）。
- 第三方销毁审计覆盖率：委托第三方监督的硬盘物理销毁占比（目标 Restricted 数据 100%）。

### 安全擦除实施

以下为多平台数据销毁工具示例，生产环境需根据介质类型选择合适方法。

```python
# 数据安全擦除工具

import os
import hashlib
import subprocess

class SecureDataErasure:
    """数据安全擦除工具"""

    def dod_wipe(self, file_path, passes=7):
        """DoD 5220.22-M 标准擦除（7 遍覆写）"""

        file_size = os.path.getsize(file_path)

        for pass_num in range(passes):
            with open(file_path, 'r+b') as f:
                if pass_num % 2 == 0:
                    # 奇数遍：写入 0x00
                    f.write(b'\x00' * file_size)
                else:
                    # 偶数遍：写入 0xFF
                    f.write(b'\xFF' * file_size)
                f.flush()
                os.fsync(f.fileno())

        # 最后一遍：写入随机数据
        with open(file_path, 'r+b') as f:
            f.write(os.urandom(file_size))
            f.flush()
            os.fsync(f.fileno())

        # 删除文件
        os.remove(file_path)

        return {
            'file': file_path,
            'method': 'DoD 5220.22-M',
            'passes': passes,
            'status': 'Securely Erased'
        }

    def crypto_erase_ssd(self, device_path):
        """SSD 加密擦除（最快且有效）"""

        # 使用 hdparm 进行 ATA Secure Erase
        try:
            # 设置密码
            subprocess.run(['hdparm', '--user-master', 'u', '--security-set-pass', 'p', device_path], check=True)

            # 执行 secure erase
            subprocess.run(['hdparm', '--user-master', 'u', '--security-erase', 'p', device_path], check=True)

            return {'device': device_path, 'method': 'ATA Secure Erase', 'status': 'Success'}

        except subprocess.CalledProcessError as e:
            return {'device': device_path, 'method': 'ATA Secure Erase', 'status': 'Failed', 'error': str(e)}

    def cloud_object_deletion(self, bucket, object_key):
        """云对象安全删除（含版本控制）"""

        import boto3
        s3 = boto3.client('s3')

        # 步骤 1：列出所有版本（包括删除标记）
        versions = s3.list_object_versions(Bucket=bucket, Prefix=object_key)

        deleted_versions = []

        # 步骤 2：删除所有版本
        if 'Versions' in versions:
            for version in versions['Versions']:
                s3.delete_object(
                    Bucket=bucket,
                    Key=version['Key'],
                    VersionId=version['VersionId']
                )
                deleted_versions.append(version['VersionId'])

        # 步骤 3：删除删除标记
        if 'DeleteMarkers' in versions:
            for marker in versions['DeleteMarkers']:
                s3.delete_object(
                    Bucket=bucket,
                    Key=marker['Key'],
                    VersionId=marker['VersionId']
                )

        # 步骤 4：验证删除
        try:
            s3.head_object(Bucket=bucket, Key=object_key)
            return {'status': 'Failed', 'reason': 'Object still exists'}
        except:
            return {
                'bucket': bucket,
                'key': object_key,
                'deleted_versions': len(deleted_versions),
                'status': 'Successfully Deleted'
            }

    def generate_deletion_certificate(self, deletion_record):
        """生成销毁证明"""

        certificate = f"""
        ═══════════════════════════════════════════════════════
        数据销毁证明
        Data Destruction Certificate
        ═══════════════════════════════════════════════════════

        销毁 ID：{deletion_record['id']}
        销毁时间：{deletion_record['timestamp']}
        执行人：{deletion_record['operator']}
        审批人：{deletion_record['approver']}

        被销毁数据资产：
        - 资产 ID：{deletion_record['asset_id']}
        - 分类：{deletion_record['classification']}
        - 数据量：{deletion_record['size']}

        销毁方法：{deletion_record['method']}
        验证状态：{deletion_record['verification']}

        符合标准：{deletion_record['compliance_standards']}

        证明 Hash：{hashlib.sha256(str(deletion_record).encode()).hexdigest()}

        ═══════════════════════════════════════════════════════
        此证明具有法律效力，请妥善保存。
        """

        return certificate
```

常见误区：
1. 仅删除文件系统元数据：使用 rm/delete 命令仅删除文件指针，数据仍在磁盘（需覆写或物理销毁）。
2. 单遍覆写不足：单遍覆写后，磁盘残留磁信号可通过专业设备恢复（需多遍覆写或物理销毁）。
3. 云对象未删除快照：删除对象但未删除 EBS 快照、AMI 镜像，数据仍可恢复。

验证方法：
- 数据恢复工具测试：使用 PhotoRec、TestDisk 等工具尝试恢复已擦除数据，验证不可恢复。
- 云对象删除审计：删除后使用 AWS CLI 列出所有版本、快照，确认完全清除。
- 第三方销毁认证：委托有资质的第三方机构（如 NAID AAA 认证）执行硬盘销毁，提供合规证书。

运行指标：
- 销毁方法合规率：使用符合标准（DoD/NIST）的销毁方法的比例（目标 100%）。
- 销毁证明生成率：所有 Restricted/Confidential 数据销毁后生成证明的比例（目标 100%）。
- 销毁后恢复测试失败率：销毁后尝试恢复失败的比例（目标 100%，即完全不可恢复）。

---

## 导航

**[← 上一节：8.2 数据分类与标记](./8.2_data_classification_labeling.md)** | **[返回章节目录](./README.md)** | **[下一节：8.4 数据加密体系 →](./8.4_data_encryption_system.md)**

---

**© 2025 AI-ESA Project. Licensed under CC BY-NC-SA 4.0**

