# 7.7 硬件供应链安全

## 概述

硬件供应链安全构成供应链安全体系的"物理维度"，覆盖从芯片设计、晶圆制造、PCB 组装到设备交付的全流程。与软件供应链相比，硬件层面的篡改具有三项显著特征：检测难度高（需专用设备与专业技能）、修复成本高（通常需物理更换而非远程升级）、影响范围深（可绕过操作系统及上层软件的全部安全控制）。

硬件后门能够在操作系统加载之前劫持系统控制权，固件级植入可持久驻留且难以通过常规安全扫描发现，物理篡改则几乎无法通过远程手段检测。这些特性使硬件供应链攻击成为高级持续威胁（APT）攻击者的重要手段。

**适用边界**：本节内容主要适用于硬件制造商、关键基础设施运营商、政府机构、金融机构及其他对硬件完整性有严格要求的组织。对于一般企业，重点关注固件安全、TPM/Secure Boot 配置、以及硬件供应商评估即可。

**关键约束**：硬件安全控制的实施受制于设备采购成本（支持 TPM 2.0 的设备通常溢价）、供应商可选范围（部分行业受地缘政治限制）、技术团队能力（固件分析需专业技能）、以及检测设备投入（X-ray 检查设备成本高）。

---

## 7.7.1 硬件供应链威胁分析

### 攻击面与攻击向量

硬件供应链的攻击面分布于五个阶段，每个阶段对应不同的攻击向量与检测难度。

**设计阶段**的风险包括：设计后门（在芯片设计中植入隐藏逻辑门）、弱随机数生成器（削弱密码学安全性）、隐藏功能（未公开的调试接口或管理通道）、以及 IP 窃取（设计文件泄露导致后续仿冒）。此阶段的攻击通常由内部人员或供应链上游的设计外包商实施，检测极其困难。

**制造阶段**的风险包括：硅级木马（在晶圆制造过程中植入额外电路）、掺杂攻击（通过改变半导体材料特性降低芯片可靠性或安全性）、掩膜修改（在光刻过程中修改电路布局）。这类攻击需要对制造设施有物理访问权限，通常针对高价值目标。

**组装阶段**的风险包括：组件替换（使用假冒或低质量元器件替代原厂件）、旧件翻新（将回收的二手组件作为新品销售）、额外组件植入（在 PCB 上焊接未经授权的芯片）。此阶段是假冒组件进入供应链的主要入口。

**运输阶段**的风险包括：物理拦截（在运输过程中截获设备并进行篡改）、包装重封（打开设备进行修改后重新封装）、物流劫持（通过伪造物流信息将设备路由至攻击者控制的地点）。此类攻击在情报机构针对性行动中有明确记录。

**部署阶段**的风险包括：固件植入（在设备首次启动前或运行过程中植入恶意固件）、UEFI rootkit（感染统一可扩展固件接口）、BMC 后门（通过基板管理控制器建立持久访问通道）、固件降级攻击（强制设备使用存在已知漏洞的旧版固件）。

![供应链攻击向量](../../../assets/images/chapter_07/01_Supply_Chain_Attack_Vectors_v6.png)

### 威胁案例参考

以下案例来自公开报道，用于说明硬件供应链威胁的类型与影响：

| 威胁类型 | 案例描述 | 特征 |
|---------|---------|------|
| 假冒组件 | 2008-2014 年间 Cisco 路由器假冒案 | 假冒设备流入市场，部分进入关键基础设施 |
| 固件后门 | 2015 年戴尔服务器 eDellRoot 证书事件 | 预装不安全证书削弱 TLS 安全性 |
| 芯片级漏洞 | 2017 年 Intel ME 漏洞披露 | 管理引擎漏洞影响大量处理器 |
| 供应链拦截 | Snowden 披露的情报机构 Interdiction 项目 | 针对性物理篡改设备 |

**常见误区**：

1. **"我们采购大品牌设备，不会有硬件安全问题"**——品牌设备仍依赖复杂的多层供应链，且物流环节存在拦截风险。
2. **"硬件篡改成本太高，攻击者不会针对我们"**——假冒组件的经济动机与针对性攻击的情报动机完全不同；假冒组件问题具有普遍性。

---

## 7.7.2 硬件安全基础技术

### 可信平台模块（TPM）

TPM（Trusted Platform Module）是专用硬件安全芯片，提供硬件级别的密钥生成、存储、密封与远程证明功能。TPM 2.0 是当前主流规范，由 TCG（Trusted Computing Group）维护。

**TPM 核心功能**：

- **密钥生成与存储**：在硬件边界内生成非对称密钥对，私钥不可导出
- **平台完整性测量**：通过 PCR（Platform Configuration Register）记录启动过程各阶段的哈希值
- **密封与解封**：将数据绑定到特定 PCR 状态，仅当平台处于预期状态时才能解密
- **远程证明**：向远程验证方证明平台处于可信状态

**PCR 扩展机制**：TPM 2.0 通常包含 24 个 PCR（索引 0-23），每个 PCR 初始化为全零。扩展操作为单向函数：`PCR_new = Hash(PCR_old || measurement)`，此操作不可逆，确保测量链的完整性。

**PCR 分配惯例**（基于 TCG PC Client Platform Firmware Profile）：

- PCR 0：UEFI 固件代码测量
- PCR 1：UEFI 固件配置
- PCR 2：Option ROM 代码
- PCR 4：Bootloader（如 GRUB2）
- PCR 5：Boot 配置
- PCR 7：Secure Boot 策略
- PCR 8-9：内核与 initramfs

```python
#!/usr/bin/env python3
"""
TPM PCR 测量验证示例
说明 PCR 扩展与远程证明的基本逻辑
"""

import hashlib
import json
from typing import Dict, List

class TPMSimulator:
    """TPM PCR 模拟器，用于理解测量机制"""

    def __init__(self):
        # TPM 2.0 通常有 24 个 PCR (0-23)，初始化为全零
        self.pcrs = {i: b'\x00' * 32 for i in range(24)}
        self.measurement_log = []

    def extend_pcr(self, pcr_index: int, measurement: bytes, description: str = ""):
        """扩展 PCR 值

        PCR 扩展为单向操作：PCR_new = Hash(PCR_old || measurement)
        """
        if pcr_index not in self.pcrs:
            raise ValueError(f"Invalid PCR index: {pcr_index}")

        current_value = self.pcrs[pcr_index]
        new_value = hashlib.sha256(current_value + measurement).digest()
        self.pcrs[pcr_index] = new_value

        self.measurement_log.append({
            'pcr_index': pcr_index,
            'measurement': measurement.hex(),
            'description': description,
            'pcr_value': new_value.hex()
        })
        return new_value

    def read_pcr(self, pcr_index: int) -> bytes:
        """读取 PCR 当前值"""
        return self.pcrs[pcr_index]

    def get_pcr_quote(self, pcr_indices: List[int]) -> Dict:
        """生成 PCR Quote 用于远程证明

        实际 TPM 中，Quote 会由 Attestation Key (AK) 签名
        """
        quote = {
            'pcrs': {},
            'nonce': 'verifier_provided_nonce'
        }
        for idx in pcr_indices:
            if idx in self.pcrs:
                quote['pcrs'][idx] = self.pcrs[idx].hex()
        # 实际实现需要 AK 签名
        quote['signature'] = 'ak_signature_placeholder'
        return quote

    def simulate_secure_boot(self):
        """模拟安全启动过程的 PCR 扩展序列"""
        print("模拟安全启动测量过程...")

        # PCR 0: UEFI 固件测量
        uefi_firmware = b"UEFI_BIOS_v2.1.0"
        self.extend_pcr(0, hashlib.sha256(uefi_firmware).digest(), "UEFI Firmware")
        print(f"[PCR 0] UEFI 固件: {uefi_firmware.decode()}")

        # PCR 1: UEFI 配置
        uefi_config = b"SecureBoot=Enabled;TPM=Enabled"
        self.extend_pcr(1, hashlib.sha256(uefi_config).digest(), "UEFI Configuration")
        print(f"[PCR 1] UEFI 配置: {uefi_config.decode()}")

        # PCR 4: Bootloader 测量
        bootloader = b"GRUB2_v2.06"
        self.extend_pcr(4, hashlib.sha256(bootloader).digest(), "Bootloader")
        print(f"[PCR 4] Bootloader: {bootloader.decode()}")

        # PCR 7: Secure Boot 策略
        secureboot_policy = b"AllowList:Microsoft,Canonical,RedHat"
        self.extend_pcr(7, hashlib.sha256(secureboot_policy).digest(), "Secure Boot Policy")
        print(f"[PCR 7] Secure Boot 策略: {secureboot_policy.decode()}")

        # PCR 8: 内核
        kernel = b"Linux-6.5.0-kernel"
        self.extend_pcr(8, hashlib.sha256(kernel).digest(), "Kernel")
        print(f"[PCR 8] Kernel: {kernel.decode()}")

        print("\n安全启动测量完成")

    def verify_platform_state(self, expected_pcrs: Dict[int, str]) -> bool:
        """验证平台状态是否与预期基线匹配"""
        print("\n验证平台状态...")
        all_match = True

        for pcr_idx, expected_value in expected_pcrs.items():
            actual_value = self.pcrs[pcr_idx].hex()
            if actual_value == expected_value:
                print(f"[PCR {pcr_idx}] 匹配")
            else:
                print(f"[PCR {pcr_idx}] 不匹配 - 期望: {expected_value[:16]}... 实际: {actual_value[:16]}...")
                all_match = False

        return all_match


if __name__ == '__main__':
    tpm = TPMSimulator()
    tpm.simulate_secure_boot()

    # 保存当前 PCR 值作为已知良好基线
    known_good_pcrs = {
        0: tpm.read_pcr(0).hex(),
        4: tpm.read_pcr(4).hex(),
        7: tpm.read_pcr(7).hex(),
        8: tpm.read_pcr(8).hex()
    }

    # 生成 PCR Quote
    quote = tpm.get_pcr_quote([0, 1, 4, 7, 8])
    print("\nPCR Quote (远程证明数据):")
    print(json.dumps(quote, indent=2))

    # 验证平台状态
    is_trusted = tpm.verify_platform_state(known_good_pcrs)
    if is_trusted:
        print("\n平台状态可信")
    else:
        print("\n平台状态不可信 - 可能存在篡改")
```

**适用边界**：TPM 主要适用于需要硬件信任根的场景，包括全盘加密（BitLocker、LUKS）、远程证明、设备身份认证。对于虚拟化环境，可使用 vTPM（虚拟 TPM），但其安全性依赖 Hypervisor 的完整性。

**关键约束**：TPM 芯片本身不能防止物理攻击（如总线嗅探）；fTPM（固件 TPM）的安全性低于 dTPM（独立芯片 TPM）；PCR 测量依赖固件正确实现，固件漏洞会削弱整体安全性。

---

### Secure Boot

Secure Boot 是 UEFI 规范的一部分，通过密码学签名验证确保只有经过授权的固件和操作系统能够启动。

**信任链结构**：

1. **Platform Key (PK)**：由设备 OEM 控制，是信任链的根
2. **Key Exchange Key (KEK)**：由操作系统厂商提供，用于更新签名数据库
3. **Signature Database (db)**：包含允许启动的可执行文件签名或证书
4. **Forbidden Signatures Database (dbx)**：包含禁止启动的签名黑名单

启动过程中，UEFI 固件依次验证 Bootloader 签名（如 shim.efi）、第二阶段 Bootloader 签名（如 GRUB2）、内核签名。任一环节验证失败，系统拒绝启动。

```bash
#!/bin/bash
# secure-boot-check.sh - Secure Boot 配置检查脚本
# 用于验证 Secure Boot 是否正确启用

set -euo pipefail

echo "Secure Boot 配置检查"
echo "========================================"

# 1. 检查 UEFI 模式
echo -e "\n[1] 启动模式检查:"
if [ -d /sys/firmware/efi ]; then
    echo "    系统以 UEFI 模式启动"
else
    echo "    系统以 Legacy BIOS 模式启动，不支持 Secure Boot"
    exit 1
fi

# 2. 检查 Secure Boot 状态
echo -e "\n[2] Secure Boot 状态:"
if [ -f /sys/firmware/efi/efivars/SecureBoot-* ] 2>/dev/null; then
    # 读取 Secure Boot 变量最后一个字节
    SB_VALUE=$(od -An -t u1 /sys/firmware/efi/efivars/SecureBoot-* 2>/dev/null | awk '{print $NF}')
    if [ "$SB_VALUE" = "1" ]; then
        echo "    Secure Boot: 已启用"
    else
        echo "    Secure Boot: 已禁用"
    fi
else
    echo "    无法读取 Secure Boot 状态"
fi

# 3. 检查 Setup Mode
echo -e "\n[3] Setup Mode 检查:"
if [ -f /sys/firmware/efi/efivars/SetupMode-* ] 2>/dev/null; then
    SM_VALUE=$(od -An -t u1 /sys/firmware/efi/efivars/SetupMode-* 2>/dev/null | awk '{print $NF}')
    if [ "$SM_VALUE" = "0" ]; then
        echo "    Setup Mode: User Mode (正常运行状态)"
    else
        echo "    Setup Mode: Setup Mode (密钥未锁定，存在风险)"
    fi
fi

# 4. 检查密钥安装状态
echo -e "\n[4] 密钥安装状态:"
for key in PK KEK db dbx; do
    if ls /sys/firmware/efi/efivars/${key}-* 1>/dev/null 2>&1; then
        echo "    $key: 已安装"
    else
        echo "    $key: 未安装"
    fi
done

# 5. 检查当前内核签名（需要 pesign 工具）
echo -e "\n[5] 内核签名检查:"
KERNEL_PATH="/boot/vmlinuz-$(uname -r)"
if [ -f "$KERNEL_PATH" ]; then
    if command -v pesign &>/dev/null; then
        if pesign -S -i "$KERNEL_PATH" 2>/dev/null | grep -q "signature"; then
            echo "    内核已签名"
        else
            echo "    内核未签名或无法验证"
        fi
    else
        echo "    pesign 工具未安装，跳过签名检查"
    fi
else
    echo "    内核文件未找到: $KERNEL_PATH"
fi

# 6. 检查已加载内核模块签名状态
echo -e "\n[6] 内核模块签名检查:"
UNSIGNED_COUNT=0
TOTAL_COUNT=0

for module in $(lsmod | awk 'NR>1 {print $1}'); do
    TOTAL_COUNT=$((TOTAL_COUNT + 1))
    if ! modinfo "$module" 2>/dev/null | grep -q "^sig_id:"; then
        UNSIGNED_COUNT=$((UNSIGNED_COUNT + 1))
    fi
done

echo "    已加载模块总数: $TOTAL_COUNT"
echo "    未签名模块数量: $UNSIGNED_COUNT"

if [ $UNSIGNED_COUNT -eq 0 ]; then
    echo "    所有模块均已签名"
else
    echo "    存在未签名模块，在强制模式下可能无法加载"
fi

echo -e "\n========================================"
echo "检查完成"
```

**验证方法**：

1. 使用上述脚本验证 Secure Boot 是否正确启用
2. 检查 Setup Mode 是否为 User Mode（Setup Mode 表示密钥可被修改）
3. 验证关键密钥（PK、KEK、db）已正确安装
4. 确认内核及 Bootloader 已签名

**常见误区**：

1. **"启用 Secure Boot 就足够安全了"**——Secure Boot 仅验证启动链，不防止运行时攻击；且 dbx 需要定期更新以包含已撤销的签名。
2. **"Secure Boot 与 Linux 不兼容"**——主流 Linux 发行版（Ubuntu、RHEL、SUSE）已支持 Secure Boot，通过 Microsoft 签名的 shim.efi 实现。

**运行指标**：

- Secure Boot 状态：启用/禁用
- Setup Mode 状态：User Mode/Setup Mode
- dbx 更新时间：最近一次更新日期
- 未签名模块加载尝试次数：通过 dmesg 或 audit 日志监控

---

## 7.7.3 硬件供应商安全评估

硬件供应商评估应覆盖制造设施安全、组件采购流程、固件安全实践、以及事件响应能力。以下评估框架提供结构化的检查维度。

### 评估维度

**制造与供应链安全**：

- 制造设施地理位置及其地缘政治风险
- 设施是否通过 ISO 28000（供应链安全管理体系）认证
- 物理访问控制措施（生物识别、双人规则、视频监控）
- 组件真实性验证方法（授权分销商采购、物理检查、X-ray）
- 监管链（Chain of Custody）完整性

**固件安全**：

- 固件开发是否遵循安全开发生命周期
- 固件是否经过 SAST/DAST 扫描
- 是否提供固件 SBOM（软件物料清单）
- 固件签名算法强度（RSA-2048+/ECDSA P-256+）
- 签名密钥保护方式（HSM 优于软件密钥库）
- 固件更新机制（加密传输、签名验证、回滚保护）

**硬件信任根**：

- 是否包含 TPM（优先 dTPM 而非 fTPM）
- TPM 版本（TPM 2.0 为当前标准）
- Secure Boot 支持情况
- 设备唯一密钥生成方式（制造时注入 vs PUF 生成）

**物理安全**：

- 防篡改检测机制（篡改时擦除密钥、记录日志、禁用设备）
- 是否经过侧信道攻击测试（功耗分析、电磁分析、时序攻击）
- 侧信道攻击对策

**事件响应**：

- 是否有公开的漏洞披露政策
- 漏洞通知时效性
- 固件/硬件召回流程

### 评估输出

评估结果应形成书面报告，包含以下要素：

1. **风险等级**：基于评估结果的综合风险评级
2. **关键发现**：识别的主要风险点
3. **整改建议**：可操作的改进措施
4. **准入决策**：批准/有条件批准/拒绝

**验证方法**：

- 现场审计（关键供应商）
- 文档审查（认证证书、流程文档）
- 技术验证（固件签名验证、TPM 功能测试）
- 第三方报告（SOC 2 Type II、ISO 27001 证书）

---

## 7.7.4 硬件篡改检测

### 检测技术对比

| 检测技术 | 检测目标 | 适用场景 | 约束条件 |
|---------|---------|---------|---------|
| X-ray 检查 | 内部组件布局异常 | 数据中心关键设备入库检查 | 设备成本高，需专业操作人员 |
| 超声波扫描 | IC 封装层分层 | 芯片级验证 | 需专用设备和参考样本 |
| 红外热成像 | 运行时异常热点 | 可疑设备运行分析 | 需建立正常热特征基线 |
| 防篡改标签 | 物理访问痕迹 | 设备运输、存储 | 仅检测物理开封，无法检测复杂攻击 |
| 序列号验证 | 假冒设备识别 | 采购验收 | 依赖厂商序列号数据库准确性 |
| 硬件指纹 | 设备身份唯一性 | 部署后持续监控 | 需建立初始基线 |

### 自动化检测工具示例

以下脚本收集系统硬件信息并生成指纹，用于检测未授权的硬件变更。

```python
#!/usr/bin/env python3
"""
硬件完整性验证工具
用于建立硬件基线并检测未授权变更
"""

import subprocess
import hashlib
import json
from typing import Dict, List
import sys

class HardwareIntegrityChecker:
    """硬件完整性检查器"""

    def __init__(self):
        self.baseline = None
        self.current = None

    def collect_hardware_info(self) -> Dict:
        """收集硬件信息"""
        info = {}

        # 1. DMI/SMBIOS 信息
        try:
            dmidecode_output = subprocess.check_output(
                ['dmidecode', '-t', 'system'],
                text=True,
                stderr=subprocess.DEVNULL
            )
            for line in dmidecode_output.split('\n'):
                if 'Manufacturer:' in line:
                    info['manufacturer'] = line.split(':')[1].strip()
                elif 'Product Name:' in line:
                    info['product_name'] = line.split(':')[1].strip()
                elif 'Serial Number:' in line:
                    info['serial_number'] = line.split(':')[1].strip()
                elif 'UUID:' in line:
                    info['uuid'] = line.split(':')[1].strip()
        except Exception as e:
            print(f"无法获取 DMI 信息: {e}")

        # 2. CPU 信息
        try:
            cpu_info = subprocess.check_output(['lscpu'], text=True)
            for line in cpu_info.split('\n'):
                if 'Model name:' in line:
                    info['cpu_model'] = line.split(':')[1].strip()
        except Exception as e:
            print(f"无法获取 CPU 信息: {e}")

        # 3. PCI 设备列表
        try:
            pci_devices = subprocess.check_output(
                ['lspci', '-nn'],
                text=True
            )
            info['pci_devices'] = pci_devices
            info['pci_device_count'] = len([l for l in pci_devices.split('\n') if l.strip()])
        except Exception as e:
            print(f"无法获取 PCI 设备: {e}")

        # 4. 网络接口 MAC 地址
        try:
            ip_output = subprocess.check_output(['ip', 'link', 'show'], text=True)
            macs = []
            for line in ip_output.split('\n'):
                if 'link/ether' in line:
                    mac = line.split()[1]
                    macs.append(mac)
            info['mac_addresses'] = macs
        except Exception as e:
            print(f"无法获取 MAC 地址: {e}")

        # 5. UEFI 固件版本
        try:
            with open('/sys/class/dmi/id/bios_version', 'r') as f:
                info['uefi_version'] = f.read().strip()
            with open('/sys/class/dmi/id/bios_date', 'r') as f:
                info['uefi_date'] = f.read().strip()
        except Exception:
            pass

        return info

    def generate_hardware_fingerprint(self, info: Dict) -> str:
        """生成硬件指纹"""
        fingerprint_data = ''.join([
            info.get('manufacturer', ''),
            info.get('product_name', ''),
            info.get('serial_number', ''),
            info.get('uuid', ''),
            info.get('cpu_model', ''),
            ''.join(info.get('mac_addresses', []))
        ])
        return hashlib.sha256(fingerprint_data.encode()).hexdigest()

    def save_baseline(self, filename: str = 'hardware_baseline.json'):
        """保存硬件基线"""
        print("收集硬件基线信息...")
        baseline = self.collect_hardware_info()
        baseline['fingerprint'] = self.generate_hardware_fingerprint(baseline)

        with open(filename, 'w') as f:
            json.dump(baseline, f, indent=2)

        print(f"硬件基线已保存到: {filename}")
        print(f"硬件指纹: {baseline['fingerprint']}")
        self.baseline = baseline

    def load_baseline(self, filename: str = 'hardware_baseline.json') -> bool:
        """加载硬件基线"""
        try:
            with open(filename, 'r') as f:
                self.baseline = json.load(f)
            print(f"已加载硬件基线: {filename}")
            return True
        except FileNotFoundError:
            print(f"基线文件未找到: {filename}")
            return False

    def verify_integrity(self) -> Dict:
        """验证硬件完整性"""
        if not self.baseline:
            print("请先加载基线")
            return {}

        print("\n开始硬件完整性验证...")
        current = self.collect_hardware_info()
        current['fingerprint'] = self.generate_hardware_fingerprint(current)
        self.current = current

        warnings = []

        # 检查硬件指纹
        if current['fingerprint'] != self.baseline['fingerprint']:
            warnings.append({
                'severity': 'CRITICAL',
                'category': 'Hardware Fingerprint',
                'message': '硬件指纹不匹配 - 可能发生硬件更换',
                'baseline': self.baseline['fingerprint'],
                'current': current['fingerprint']
            })

        # 检查关键字段
        critical_fields = ['manufacturer', 'product_name', 'serial_number', 'uuid', 'cpu_model']
        for field in critical_fields:
            baseline_value = self.baseline.get(field, 'N/A')
            current_value = current.get(field, 'N/A')
            if baseline_value != current_value:
                severity = 'CRITICAL' if field in ['uuid', 'serial_number'] else 'HIGH'
                warnings.append({
                    'severity': severity,
                    'category': field,
                    'message': f'{field} 已变更',
                    'baseline': baseline_value,
                    'current': current_value
                })

        # 检查 PCI 设备数量
        baseline_pci = self.baseline.get('pci_device_count', 0)
        current_pci = current.get('pci_device_count', 0)
        if current_pci != baseline_pci:
            warnings.append({
                'severity': 'MEDIUM',
                'category': 'PCI Devices',
                'message': f'PCI 设备数量变化: {baseline_pci} -> {current_pci}'
            })

        # 检查 UEFI 版本
        baseline_uefi = self.baseline.get('uefi_version', 'N/A')
        current_uefi = current.get('uefi_version', 'N/A')
        if baseline_uefi != current_uefi:
            warnings.append({
                'severity': 'HIGH',
                'category': 'UEFI Firmware',
                'message': f'UEFI 版本变化: {baseline_uefi} -> {current_uefi}'
            })

        # 生成报告
        report = {
            'fingerprint_match': current['fingerprint'] == self.baseline['fingerprint'],
            'warnings': warnings,
            'risk_level': self._calculate_risk_level(warnings)
        }

        self._print_report(report)
        return report

    def _calculate_risk_level(self, warnings: List[Dict]) -> str:
        """计算风险等级"""
        critical_count = sum(1 for w in warnings if w['severity'] == 'CRITICAL')
        high_count = sum(1 for w in warnings if w['severity'] == 'HIGH')

        if critical_count > 0:
            return 'CRITICAL'
        elif high_count > 0:
            return 'HIGH'
        elif len(warnings) > 0:
            return 'MEDIUM'
        else:
            return 'LOW'

    def _print_report(self, report: Dict):
        """打印验证报告"""
        print("\n" + "=" * 60)
        print("硬件完整性验证报告")
        print("=" * 60)

        print(f"\n硬件指纹匹配: {'是' if report['fingerprint_match'] else '否'}")
        print(f"告警数量: {len(report['warnings'])}")
        print(f"风险等级: {report['risk_level']}")

        if report['warnings']:
            print("\n告警详情:")
            print("-" * 60)
            for idx, warning in enumerate(report['warnings'], 1):
                print(f"\n{idx}. [{warning['severity']}] {warning['category']}")
                print(f"   {warning['message']}")
                if 'baseline' in warning:
                    print(f"   基线: {warning['baseline']}")
                    print(f"   当前: {warning['current']}")
        else:
            print("\n未发现硬件变更")

        print("\n" + "=" * 60)


if __name__ == '__main__':
    checker = HardwareIntegrityChecker()

    if len(sys.argv) > 1 and sys.argv[1] == 'baseline':
        checker.save_baseline()
    elif len(sys.argv) > 1 and sys.argv[1] == 'verify':
        if checker.load_baseline():
            report = checker.verify_integrity()
            if report['risk_level'] in ['CRITICAL', 'HIGH']:
                sys.exit(1)
            else:
                sys.exit(0)
    else:
        print("用法:")
        print("  创建基线: sudo python3 hardware_integrity_checker.py baseline")
        print("  验证完整性: sudo python3 hardware_integrity_checker.py verify")
```

**适用边界**：此工具适用于物理服务器和裸金属环境；虚拟机环境中的硬件信息由 Hypervisor 虚拟化，检测价值有限。

**验证方法**：

1. 在设备入库时建立初始基线
2. 定期（建议每周或每次维护后）运行验证
3. 将验证结果集成到监控系统，对 CRITICAL/HIGH 风险告警
4. 对于告警事件，人工核实是否为授权变更

**运行指标**：

- 基线覆盖率：已建立基线的设备占比
- 验证执行率：按计划执行验证的设备占比
- 告警数量（按风险等级分类）
- 告警处置时效

---

## 7.7.5 实施检查清单

以下清单按成熟度等级组织，组织可根据自身风险状况和资源约束选择适用的控制项。

### Level 1：基础（适用于一般企业）

**采购与验收**
- [ ] 仅从授权渠道采购硬件设备
- [ ] 执行基础外观检查（包装完整性、标签一致性）
- [ ] 验证设备序列号与采购记录一致

**固件安全**
- [ ] 记录所有设备的固件版本
- [ ] 建立固件更新流程，定期检查并应用更新

**物理安全**
- [ ] 数据中心实施门禁控制
- [ ] 部署视频监控覆盖设备区域

### Level 2：管理（适用于需合规的企业）

**采购与验收**
- [ ] 对关键硬件供应商执行安全评估
- [ ] 验证组件真实性（检查防伪标识、查询厂商数据库）
- [ ] 为关键设备建立硬件基线

**固件安全**
- [ ] 启用固件签名验证
- [ ] 启用 Secure Boot
- [ ] 部署支持 TPM 2.0 的设备并启用 TPM

**物理安全**
- [ ] 对运输中的设备使用防篡改封条
- [ ] 定期执行物理安全审计

### Level 3：优化（适用于关键基础设施）

**采购与验收**
- [ ] 对关键设备执行 X-ray 检查
- [ ] 部署自动化硬件完整性验证
- [ ] 建立供应链全程可追溯记录

**固件安全**
- [ ] 生成固件 SBOM
- [ ] 持续监控固件漏洞并及时响应

**物理安全**
- [ ] 评估设备的侧信道攻击防护能力

### Level 4：先进（适用于国防/情报机构）

- [ ] 采用 PUF（物理不可克隆函数）技术验证芯片唯一性
- [ ] 部署硅级篡改检测机制

---

## 关键要点

1. **硬件篡改检测依赖专用技术**——与软件供应链不同，硬件篡改检测需要 X-ray、超声波等物理检测手段，或依赖 TPM/Secure Boot 提供的密码学验证。

2. **硬件信任根是基础**——TPM 和 Secure Boot 提供从硬件到操作系统启动的信任链，是构建可信计算环境的基础。

3. **固件是关键攻击面**——固件后门可在操作系统加载前获得控制权，绕过所有上层安全控制；固件安全应纳入供应商评估和持续监控范围。

4. **供应商评估不可省略**——硬件供应链的复杂性意味着企业难以独自验证每个组件的安全性；系统性的供应商评估是风险管控的关键手段。

5. **持续验证优于一次性检查**——硬件完整性验证应作为持续运营活动，而非仅在采购验收时执行。

---

## 参考标准

- NIST SP 800-193: Platform Firmware Resiliency Guidelines
- NIST SP 800-147: BIOS Protection Guidelines
- TCG: Trusted Platform Module Library Specification (TPM 2.0)
- UEFI Specification (Secure Boot)
- ISO/IEC 27001: Annex A.11 - Physical and Environmental Security
- ISO 28000: Supply Chain Security Management Systems

---

## 导航

**[← 7.6 供应商与第三方安全管理](./7.6_vendor_third_party_security.md)** | **[返回章节目录](./README.md)** | **[7.8 供应链风险检测与响应 →](./7.8_supply_chain_risk_detection.md)**

---

**© 2025 AI-ESA Project. Licensed under CC BY-NC-SA 4.0**

