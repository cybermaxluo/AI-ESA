# 7.4 CI/CD 供应链安全

CI/CD 管道是现代软件供应链的核心枢纽，也是攻击者的高价值目标。CI/CD 系统一旦被攻陷，攻击者可实现以下目标：在生产制品中注入恶意代码、窃取构建环境中的密钥与凭证、篡改构建产物同时保留合法签名、在构建过程中植入持久后门。SolarWinds、Codecov、Travis CI 等事件表明，CI/CD 安全是供应链防御的关键控制点。

本节从攻击面分析入手，逐步展开 CI/CD 加固基线、SLSA 框架分级实施，以及 hermetic builds 的工程实现。

---

## 7.4.1 CI/CD 攻击面分析

### 威胁模型

CI/CD 供应链攻击可沿四个阶段发生：源代码仓库、构建系统、制品仓库、部署环境。每个阶段存在不同的攻击向量。

源代码仓库阶段的风险包括恶意 pull request、分支保护绕过、提交签名伪造。攻击者通过社会工程或账户接管提交恶意代码，若分支保护规则配置不当，恶意代码可能直接合入主干。

构建系统阶段的风险集中在 CI 配置文件篡改（如 `.gitlab-ci.yml`、GitHub Actions workflow）、构建脚本注入、环境变量窃取。攻击者可通过修改构建定义执行任意命令，或窃取构建环境中的凭证。

制品仓库阶段面临中间人攻击、仓库账户劫持、签名伪造等威胁。攻击者可替换合法制品或伪造签名，使下游系统接受恶意产物。

部署环境阶段的风险包括 Kubernetes API 滥用、secrets 泄露、准入控制绕过。攻击者可利用部署凭证直接操作生产环境。

![CI/CD 供应链攻击向量](../../../assets/images/chapter_07/01_Supply_Chain_Attack_Vectors_v6.png)

### 风险矩阵

下表汇总主要攻击向量的风险评估。评估维度包括可能性、影响程度、风险等级，并关联已知案例。

| 攻击向量 | 可能性 | 影响 | 风险等级 | 案例参考 |
|---------|-------|------|---------|----------|
| CI 配置文件篡改 | 高 | 高 | 严重 | Codecov (2021) |
| 构建环境投毒 | 中 | 极高 | 严重 | SolarWinds (2020) |
| 密钥窃取 | 高 | 高 | 严重 | Travis CI (2021) |
| 依赖混淆 | 中 | 高 | 高 | 依赖混淆攻击 (2021) |
| 制品替换 | 低 | 极高 | 高 | NPM 供应链事件 (2022) |
| 日志投毒 | 低 | 低 | 中 | —— |

适用边界: 该风险矩阵适用于使用 Git 托管平台（GitHub、GitLab、Bitbucket）并采用自动化 CI/CD 的组织。对于完全隔离的构建环境或无外部依赖的场景，部分风险等级可能降低。

关键约束: 风险等级评估基于典型互联网企业场景，实际评估需结合组织的资产价值、暴露面、现有控制措施进行调整。

---

## 7.4.2 CI/CD 加固基线

### GitHub Actions 安全配置

#### workflow 安全实践

GitHub Actions 的安全加固需从权限控制、版本固定、输入隔离三个层面入手。

权限最小化原则：在 workflow 文件中显式声明 `permissions` 块，默认应为只读权限。仅在必要时授予 `write` 权限，避免使用隐式的最大权限。

Action 版本固定：使用完整 SHA 哈希固定 Action 版本，而非 tag 或 branch。这可防止攻击者通过篡改 tag 指向或修改 Action 代码实施供应链攻击。

不可信输入隔离：避免使用 `pull_request_target` 触发器处理外部 PR，因其在目标仓库上下文中运行，可能导致代码注入。对所有用户输入进行过滤和转义。

```yaml
# .github/workflows/secure-workflow.yaml
name: Secure CI/CD Pipeline

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main]

permissions:
  contents: read
  pull-requests: write
  id-token: write
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  security-checks:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      # 使用 SHA 固定 Action 版本
      - name: Checkout code
        uses: actions/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab # v3.5.2
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@64ed1c7eab4cce3362f8c340dee64e5eaeef8f7c # v3.6.0
        with:
          node-version: '18'
          cache: 'npm'

      # 验证外部脚本完整性
      - name: Download and verify script
        run: |
          curl -o script.sh https://trusted-source.com/script.sh
          echo "expected_sha256_hash script.sh" | sha256sum -c -
          chmod +x script.sh
          ./script.sh

      - name: Build application
        env:
          NODE_ENV: production
        run: |
          npm ci --production
          npm run build

      - name: Deploy to production
        env:
          DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
        run: |
          ./deploy.sh
```

常见误区:

1. 使用 tag 而非 SHA 固定版本: tag 可被修改指向不同提交，SHA 是唯一不可变标识
2. 在日志中输出密钥: 即使 GitHub 会自动遮盖，也应避免在调试信息中引用密钥变量
3. 对 PR 标题/内容直接插值执行: 可导致命令注入，应使用 `github-script` 等安全方式处理

验证方法:

- 使用 `actionlint` 工具静态分析 workflow 文件
- 审查 workflow 执行日志，确认无密钥泄露
- 定期审计 Action 版本，检查是否存在已知漏洞

#### 分支保护规则

分支保护是防止恶意代码合入主干的关键控制。以下 Terraform 配置展示完整的保护规则设置：

```hcl
# terraform/github_branch_protection.tf
resource "github_branch_protection" "main" {
  repository_id = github_repository.repo.node_id
  pattern       = "main"

  required_status_checks {
    strict   = true
    contexts = [
      "security-checks",
      "unit-tests",
      "integration-tests",
      "code-quality",
    ]
  }

  required_pull_request_reviews {
    dismiss_stale_reviews           = true
    require_code_owner_reviews      = true
    required_approving_review_count = 2
    restrict_dismissals             = true
    dismissal_restrictions = [
      "security-team",
      "lead-engineers",
    ]
  }

  require_signed_commits        = true
  enforce_admins                = true
  allows_force_pushes           = false
  allows_deletions              = false
  required_conversation_resolution = true

  push_restrictions = [
    "ci-bot",
    "release-automation",
  ]
}
```

CODEOWNERS 配置示例：

```
# .github/CODEOWNERS
* @security-team @lead-engineers
/.github/workflows/ @devops-team @security-team
/infrastructure/ @platform-team @security-team
/src/security/ @security-team
/config/production.yaml @security-team
*.key @security-team
*.pem @security-team
```

运行指标:

- 分支保护绕过尝试次数
- 未经审查合入的提交数量
- 签名验证失败率

---

### GitLab CI/CD 安全配置

#### pipeline 安全实践

GitLab CI/CD 的安全加固重点在于触发规则限制、安全扫描集成、镜像签名验证。

```yaml
# .gitlab-ci.yml
workflow:
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  SAST_DISABLED: "false"
  SECRET_DETECTION_DISABLED: "false"
  DEPENDENCY_SCANNING_DISABLED: "false"
  CONTAINER_SCANNING_DISABLED: "false"

stages:
  - security
  - build
  - test
  - scan
  - deploy

include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Container-Scanning.gitlab-ci.yml

sast:
  stage: security
  variables:
    SAST_EXCLUDED_PATHS: "spec,test,tests,tmp,node_modules"
  artifacts:
    reports:
      sast: gl-sast-report.json
    paths:
      - gl-sast-report.json
    expire_in: 1 week

secret_detection:
  stage: security
  variables:
    SECRET_DETECTION_HISTORIC_SCAN: "true"

build:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - apk add --no-cache cosign
    - cosign verify --key cosign.pub $CI_REGISTRY_IMAGE:base || exit 1
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - syft packages $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -o cyclonedx-json > sbom.json
    - cosign sign --key cosign.key $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - cosign attest --key cosign.key --predicate sbom.json $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  artifacts:
    paths:
      - sbom.json
    reports:
      cyclonedx: sbom.json
  only:
    - main
    - /^release-.*$/

container_scanning:
  stage: scan
  variables:
    CS_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    CS_SEVERITY_THRESHOLD: "CRITICAL"
  dependencies:
    - build
  allow_failure: false

deploy_production:
  stage: deploy
  image: bitnami/kubectl:latest
  before_script:
    - cosign verify --key cosign.pub $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - cosign verify-attestation --key cosign.pub \
        --type cyclonedx \
        $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  script:
    - kubectl set image deployment/app \
        app=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA \
        --namespace=production
  environment:
    name: production
    url: https://app.example.com
  only:
    - main
  when: manual
```

#### GitLab Runner 加固

Runner 配置直接影响构建环境的隔离性和安全性。以下配置展示关键加固选项：

```toml
# /etc/gitlab-runner/config.toml
concurrent = 4
check_interval = 0

[session_server]
  session_timeout = 1800

[[runners]]
  name = "secure-docker-runner"
  url = "https://gitlab.example.com"
  token = "RUNNER_TOKEN"
  executor = "docker"
  run_untagged = false
  tag_list = ["secure", "production"]

  [runners.docker]
    tls_verify = true
    image = "alpine:latest"
    privileged = false
    disable_cache = false
    volumes = ["/cache"]
    shm_size = 0
    network_mode = "bridge"
    dns = ["8.8.8.8", "8.8.4.4"]
    memory = "2g"
    memory_swap = "2g"
    memory_reservation = "1g"
    cpus = "2"
    security_opt = ["no-new-privileges:true"]
    cap_drop = ["ALL"]
    cap_add = ["NET_BIND_SERVICE"]
    read_only = true
    tmpfs = {"/tmp" = "rw,noexec,nosuid,size=100m"}

  [runners.cache]
    Type = "s3"
    Shared = false
    [runners.cache.s3]
      ServerAddress = "s3.amazonaws.com"
      BucketName = "gitlab-runner-cache"
      BucketLocation = "us-east-1"
      Insecure = false
      AuthenticationType = "iam"
```

关键约束:

- `privileged = false` 禁止特权容器，防止容器逃逸
- `read_only = true` 只读根文件系统，限制持久化能力
- `cap_drop = ["ALL"]` 移除所有 Linux capabilities，按需添加

---

### Jenkins 安全加固

#### declarative pipeline 安全实践

Jenkins pipeline 的安全加固需关注 agent 配置、凭证管理、构建隔离。

```groovy
// Jenkinsfile
@Library('security-shared-library') _

pipeline {
    agent {
        kubernetes {
            yaml """
apiVersion: v1
kind: Pod
metadata:
  labels:
    jenkins: agent
spec:
  serviceAccountName: jenkins-agent-sa
  securityContext:
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
  containers:
  - name: build
    image: maven:3.9-eclipse-temurin-17
    command: ['cat']
    tty: true
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      capabilities:
        drop: ['ALL']
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
"""
        }
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        disableConcurrentBuilds()
        timeout(time: 30, unit: 'MINUTES')
        timestamps()
        skipDefaultCheckout(false)
    }

    environment {
        ARTIFACTORY_CREDS = credentials('artifactory-credentials')
        COSIGN_PRIVATE_KEY = credentials('cosign-private-key')
        HOME = "${WORKSPACE}"
        MAVEN_OPTS = '-Dmaven.repo.local=${WORKSPACE}/.m2/repository'
    }

    stages {
        stage('Security Checks') {
            parallel {
                stage('Code Analysis') {
                    steps {
                        container('build') {
                            sh './mvnw spotbugs:check'
                            sh 'trufflehog filesystem --directory=. --json > trufflehog-results.json'
                            recordIssues(tools: [spotBugs()])
                        }
                    }
                }
                stage('Dependency Check') {
                    steps {
                        container('build') {
                            sh './mvnw dependency-check:check'
                            sh 'syft packages . -o cyclonedx-json > sbom.json'
                            dependencyTrackPublisher(
                                artifact: 'sbom.json',
                                projectName: 'myapp',
                                projectVersion: "${env.BUILD_NUMBER}",
                                synchronous: true,
                                failOnError: true
                            )
                        }
                    }
                }
            }
        }

        stage('Build') {
            steps {
                container('build') {
                    sh './mvnw verify -DskipTests'
                    sh './mvnw clean package -DskipTests'
                    archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
                }
            }
        }

        stage('Sign & Attest') {
            steps {
                container('build') {
                    script {
                        sh '''
                            cosign sign-blob --key ${COSIGN_PRIVATE_KEY} \
                                --output-signature=target/app.jar.sig \
                                target/app.jar
                        '''
                        def provenance = generateSLSAProvenance(
                            artifact: 'target/app.jar',
                            builder: 'jenkins',
                            buildDefinition: env.BUILD_URL
                        )
                        writeFile file: 'provenance.json', text: provenance
                        sh '''
                            cosign attest --key ${COSIGN_PRIVATE_KEY} \
                                --predicate provenance.json \
                                target/app.jar
                        '''
                    }
                }
            }
        }

        stage('Container Build') {
            steps {
                container('build') {
                    script {
                        sh '''
                            /kaniko/executor \
                                --dockerfile=Dockerfile \
                                --context=. \
                                --destination=myregistry.io/myapp:${BUILD_NUMBER} \
                                --cache=true \
                                --cache-repo=myregistry.io/cache \
                                --snapshot-mode=redo \
                                --push-retry=3
                        '''
                        sh '''
                            trivy image \
                                --severity HIGH,CRITICAL \
                                --exit-code 1 \
                                --no-progress \
                                myregistry.io/myapp:${BUILD_NUMBER}
                        '''
                        sh '''
                            cosign sign --key ${COSIGN_PRIVATE_KEY} \
                                myregistry.io/myapp:${BUILD_NUMBER}
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs(deleteDirs: true, patterns: [
                [pattern: '**/*.key', type: 'INCLUDE'],
                [pattern: '**/*.pem', type: 'INCLUDE'],
                [pattern: '.m2/settings.xml', type: 'INCLUDE']
            ])
        }
        failure {
            emailext(
                subject: "Security Pipeline Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                body: """
                    Pipeline failed security checks.
                    Build: ${env.BUILD_URL}
                    Branch: ${env.BRANCH_NAME}
                    Commit: ${env.GIT_COMMIT}
                """,
                to: 'security-team@example.com'
            )
        }
    }
}
```

#### Jenkins 系统加固

Jenkins 实例本身需要进行安全加固，包括启用 CSRF 保护、配置授权策略、禁用不安全协议。

```groovy
// /var/jenkins_home/init.groovy.d/security-hardening.groovy
import jenkins.model.Jenkins
import jenkins.security.s2m.AdminWhitelistRule
import hudson.security.*
import hudson.security.csrf.DefaultCrumbIssuer
import jenkins.security.ApiTokenProperty

def instance = Jenkins.getInstance()

// 启用 CSRF 保护
if (instance.getCrumbIssuer() == null) {
    instance.setCrumbIssuer(new DefaultCrumbIssuer(true))
}

// 配置授权策略
def strategy = new ProjectMatrixAuthorizationStrategy()
strategy.add(Jenkins.ADMINISTER, "admin")
strategy.add(Jenkins.READ, "authenticated")
instance.setAuthorizationStrategy(strategy)

// 禁用 Agent 到 Controller 不安全协议
def masterKillSwitch = instance.getDescriptor(AdminWhitelistRule.class)
masterKillSwitch.setMasterKillSwitch(false)

// 配置安全的标记格式器
import org.jenkinsci.plugins.antisamy.AntiSamyMarkupFormatter
instance.setMarkupFormatter(new AntiSamyMarkupFormatter(""))

// 禁用旧 CLI 协议
def protocols = instance.getAgentProtocols() as Set
protocols.removeAll(['JNLP-connect', 'JNLP2-connect', 'JNLP3-connect', 'CLI-connect', 'CLI2-connect'])
instance.setAgentProtocols(protocols)

// 禁用旧版 API Token
ApiTokenProperty.DescriptorImpl apiTokenDescriptor =
    instance.getDescriptorByType(ApiTokenProperty.DescriptorImpl.class)
apiTokenDescriptor.setCreationOfLegacyTokenEnabled(false)

instance.save()
```

---

## 7.4.3 SLSA 框架实施路线图

SLSA（supply-chain levels for software artifacts）提供分级的供应链安全成熟度框架。从 Level 1 到 Level 4，要求逐步提升，组织应根据风险承受能力和资源约束选择目标等级。

![SLSA 框架](../../../assets/images/chapter_07/03_SLSA_Framework_v6.png)

### SLSA Level 1：构建证明

目标：记录构建过程的基本信息，为后续审计提供依据。

Level 1 的核心要求是生成构建证明（provenance），记录构建发生的位置、时间、使用的构建定义。此阶段不要求签名。

```yaml
# GitHub Actions: SLSA Level 1
name: SLSA Level 1 Build

on:
  push:
    branches: [main]
  release:
    types: [published]

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      - name: Build artifact
        id: build
        run: |
          make build
          sha256sum target/app.jar | tee app.jar.sha256
          echo "digest=$(cut -d' ' -f1 app.jar.sha256)" >> $GITHUB_OUTPUT

      - name: Generate basic provenance
        run: |
          cat > provenance.json <<EOF
          {
            "builder": {
              "id": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            },
            "recipe": {
              "type": "github-actions",
              "definedInMaterial": "${{ github.sha }}",
              "entryPoint": ".github/workflows/build.yaml"
            },
            "metadata": {
              "buildStartedOn": "${{ github.event.head_commit.timestamp }}",
              "buildFinishedOn": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "completeness": {
                "parameters": false,
                "environment": false,
                "materials": false
              },
              "reproducible": false
            }
          }
          EOF

      - uses: actions/upload-artifact@v3
        with:
          name: provenance
          path: provenance.json
```

Level 1 要求清单:

- 记录构建过程
- 生成证明文件
- 签名非必需

---

### SLSA Level 2：签名证明

目标：为证明添加防篡改签名，确保证明完整性。

Level 2 引入签名要求，使用 Sigstore 等签名服务对证明进行密码学签名。这确保证明在生成后未被篡改。

```yaml
# GitHub Actions: SLSA Level 2
name: SLSA Level 2 Build

on:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: read
  packages: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build
        run: make build

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign artifact with Sigstore (keyless)
        run: |
          cosign sign-blob --yes \
            --bundle=app.jar.bundle \
            target/app.jar

      - name: Generate SLSA provenance
        uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1.9.0
        with:
          provenance-name: app.jar.intoto.jsonl
          base64-subjects: ${{ steps.hash.outputs.hash }}

      - name: Verify provenance
        run: |
          slsa-verifier verify-artifact \
            --provenance-path app.jar.intoto.jsonl \
            --source-uri github.com/${{ github.repository }} \
            target/app.jar
```

Level 2 要求清单:

- SLSA L1 所有要求
- 使用签名服务（Sigstore）
- 防篡改证明
- 托管构建平台（非自建）

---

### SLSA Level 3：加固构建

目标：隔离的、不可篡改的构建环境。

Level 3 要求构建在隔离环境中执行，构建过程对攻击者不可篡改。这通常通过容器隔离、只读文件系统、最小化基础镜像实现。

```yaml
# .github/workflows/slsa-l3.yaml
name: SLSA Level 3 Build

on:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: read
  actions: read
  packages: write

jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: cgr.dev/chainguard/wolfi-base:latest
      options: --read-only --security-opt=no-new-privileges:true

    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Setup Bazel (hermetic build tool)
        run: |
          wget https://github.com/bazelbuild/bazel/releases/download/6.4.0/bazel-6.4.0-linux-x86_64
          echo "expected_sha256 bazel-6.4.0-linux-x86_64" | sha256sum -c -
          chmod +x bazel-6.4.0-linux-x86_64
          ./bazel-6.4.0-linux-x86_64 version

      - name: Hermetic build
        run: |
          ./bazel-6.4.0-linux-x86_64 build //... \
            --spawn_strategy=sandboxed \
            --experimental_strict_action_env \
            --action_env=PATH=/usr/bin:/bin

      - name: Generate SLSA L3 provenance
        uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v1.9.0
        with:
          image: ghcr.io/${{ github.repository }}
          digest: ${{ steps.build.outputs.digest }}
          registry-username: ${{ github.actor }}
          registry-password: ${{ secrets.GITHUB_TOKEN }}

  verify:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Install slsa-verifier
        run: |
          wget https://github.com/slsa-framework/slsa-verifier/releases/download/v2.4.1/slsa-verifier-linux-amd64
          chmod +x slsa-verifier-linux-amd64

      - name: Verify SLSA provenance
        run: |
          ./slsa-verifier-linux-amd64 verify-image \
            ghcr.io/${{ github.repository }}:${{ github.sha }} \
            --source-uri github.com/${{ github.repository }} \
            --source-tag ${{ github.ref_name }}
```

Level 3 要求清单:

- SLSA L2 所有要求
- 隔离构建环境
- 防篡改证明生成
- 不可变基础设施
- 审计所有构建步骤

---

### SLSA Level 4：双人审查

目标：所有变更需要两方审查。

Level 4 是最高等级，要求构建定义与源代码分离存储，所有变更需独立审查。这需要组织流程配合技术控制。

```yaml
# myapp-build-config/.github/workflows/build.yaml
# 构建配置独立仓库，与应用代码分离
name: SLSA L4 Hermetic Build

on:
  repository_dispatch:
    types: [trigger-build]

jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: gcr.io/company/hermetic-builder:v2.1.0

    steps:
      - name: Checkout application source
        uses: actions/checkout@v4
        with:
          repository: company/myapp
          ref: ${{ github.event.client_payload.sha }}
          persist-credentials: false

      - name: Verify dependencies
        run: |
          sha256sum -c DEPENDENCIES_SHA256SUMS

      - name: Build with Bazel
        run: |
          bazel build //... \
            --spawn_strategy=standalone \
            --experimental_strict_action_env \
            --action_env=PATH=/usr/bin:/bin \
            --noexperimental_check_external_repository_files \
            --repository_cache=/workspace/cache

      - name: Generate comprehensive provenance
        run: |
          slsa-provenance-generator \
            --artifact=bazel-bin/app \
            --builder-id="https://github.com/company/myapp-build-config" \
            --materials="$(bazel query 'deps(//...)' --output=json)" \
            --recipe-type="https://slsa.dev/bazel-build/v1" \
            --output=provenance.intoto.jsonl

      - name: Sign with HSM
        uses: company/hsm-signer-action@v2
        with:
          artifact: bazel-bin/app
          provenance: provenance.intoto.jsonl
          hsm-url: ${{ secrets.HSM_URL }}
          key-id: ${{ secrets.SIGNING_KEY_ID }}
```

Level 4 要求清单:

- SLSA L3 所有要求
- 所有变更需两方审查
- 构建定义与源代码分离
- Hermetic builds（完全确定性）
- 完整依赖图证明

适用边界: SLSA Level 4 适用于高安全要求场景，如金融基础设施、关键国家基础设施。对于大多数企业，Level 2-3 可能是更务实的目标。

常见误区:

1. 认为达成 SLSA 等级即完成安全建设: SLSA 聚焦构建完整性，不涵盖运行时安全、访问控制等领域
2. 跳过低等级直接追求高等级: 各等级是递进关系，跳级可能导致基础薄弱

---

## 7.4.4 Hermetic Builds 实现

Hermetic build（密封构建）指构建过程完全确定，不依赖构建机器的状态或外部网络。相同输入必须产生相同输出。

### 使用 Bazel 实现 Hermetic Build

Bazel 是实现 hermetic build 的主流工具，通过沙箱执行和依赖锁定确保构建可重现。

```python
# BUILD.bazel
load("@rules_java//java:defs.bzl", "java_binary", "java_library")

java_library(
    name = "mylib",
    srcs = glob(["src/main/java/**/*.java"]),
    deps = [
        "@maven//:com_google_guava_guava",
        "@maven//:org_slf4j_slf4j_api",
    ],
)

java_binary(
    name = "myapp",
    main_class = "com.example.Main",
    runtime_deps = [":mylib"],
)
```

```python
# WORKSPACE
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

http_archive(
    name = "rules_jvm_external",
    sha256 = "expected_sha256_hash_here",
    strip_prefix = "rules_jvm_external-5.2",
    url = "https://github.com/bazelbuild/rules_jvm_external/releases/download/5.2/rules_jvm_external-5.2.tar.gz",
)

load("@rules_jvm_external//:defs.bzl", "maven_install")

maven_install(
    artifacts = [
        "com.google.guava:guava:32.1.2-jre",
        "org.slf4j:slf4j-api:2.0.9",
        "org.slf4j:slf4j-simple:2.0.9",
    ],
    repositories = [
        "https://repo1.maven.org/maven2",
    ],
    maven_install_json = "//:maven_install.json",
    fetch_sources = True,
)

load("@maven//:defs.bzl", "pinned_maven_install")
pinned_maven_install()
```

```bash
# 生成依赖锁文件
bazel run @maven//:pin

# Hermetic build 命令
bazel build //myapp:myapp \
  --spawn_strategy=standalone \
  --experimental_strict_action_env \
  --action_env=PATH=/usr/bin:/bin \
  --sandbox_default_allow_network=false \
  --incompatible_strict_action_env=true

# 验证构建可重现性
bazel clean --expunge
bazel build //myapp:myapp
sha256sum bazel-bin/myapp/myapp
```

### 使用 Nix 实现 Hermetic Build

Nix 通过声明式依赖管理实现构建可重现性。

```nix
# default.nix
{ pkgs ? import <nixpkgs> {
    rev = "23.11";
    sha256 = "expected_sha256_here";
  }
}:

pkgs.stdenv.mkDerivation rec {
  pname = "myapp";
  version = "1.0.0";

  src = ./.;

  nativeBuildInputs = with pkgs; [
    maven
    jdk17
  ];

  buildInputs = with pkgs; [
    jre17
  ];

  buildPhase = ''
    mvn package -o -Dmaven.repo.local=$out/.m2
  '';

  installPhase = ''
    mkdir -p $out/bin
    cp target/*.jar $out/bin/
  '';

  outputHashMode = "recursive";
  outputHashAlgo = "sha256";
  outputHash = "expected_output_hash";
}
```

```bash
# Hermetic build
nix-build default.nix

# 验证可重现性
nix-build default.nix --rebuild
sha256sum result/bin/myapp.jar
```

验证方法:

- 在不同机器上执行构建，比对产物哈希
- 清除所有缓存后重新构建，验证哈希一致性
- 记录构建环境信息，用于审计和回溯

关键约束:

- Hermetic build 要求所有依赖预先声明并锁定版本
- 构建过程不能访问外部网络（构建时网络隔离）
- 初始设置成本较高，需要完整的依赖分析

---

## 7.4.5 实践检查清单

以下检查清单用于评估 CI/CD 安全成熟度。评分仅供内部参考，不代表绝对安全水平。

### 基础安全（第一阶段）

访问控制:

- [ ] 所有 CI/CD 账户启用 MFA
- [ ] 使用基于角色的访问控制（RBAC）
- [ ] 定期审计访问权限
- [ ] 使用服务账户而非个人账户

密钥管理:

- [ ] 使用原生密钥管理（GitHub Secrets、GitLab CI Variables）
- [ ] 密钥不在日志中显示
- [ ] 定期轮换密钥
- [ ] 使用短期令牌（OIDC）

pipeline 配置:

- [ ] 分支保护规则已启用
- [ ] 需要代码审查才能合并
- [ ] pipeline 文件变更需要审查

### 中级安全（第二阶段）

构建安全:

- [ ] 使用固定版本的 actions/images
- [ ] 验证外部脚本完整性
- [ ] 隔离构建环境
- [ ] 最小权限 pipeline

制品安全:

- [ ] 生成 SBOM
- [ ] 基础制品签名
- [ ] SCA 扫描集成
- [ ] 容器镜像扫描

监控与审计:

- [ ] 记录所有 pipeline 执行
- [ ] 异常活动告警
- [ ] 定期安全审计

### 高级安全（第三阶段）

SLSA 实施:

- [ ] SLSA Level 2 证明
- [ ] Sigstore/Cosign 签名
- [ ] 准入控制（OPA/Kyverno）

构建完整性:

- [ ] Hermetic builds（Bazel/Nix）
- [ ] 构建可重现性验证
- [ ] 依赖锁定与哈希验证

### 专家级安全（第四阶段）

- [ ] 达成 SLSA Level 4

运行指标:

- pipeline 安全扫描覆盖率
- 密钥轮换周期达标率
- 分支保护规则绕过事件数
- SBOM 生成覆盖率
- 制品签名验证通过率

---

## 本节要点

1. CI/CD 是供应链的关键控制点：从 SolarWinds 到 Codecov，主要供应链攻击均涉及 CI/CD 系统入侵。构建环境的安全性直接决定最终制品的可信度。

2. 最小权限原则贯穿始终：pipeline 应仅获得完成任务所需的最小权限。显式声明权限、禁用不必要的凭证持久化、隔离敏感操作。

3. SLSA 提供渐进式进阶路径：从 Level 1 的基础证明到 Level 4 的双人审查，组织可根据风险承受能力和资源约束选择目标等级。

4. hermetic build 是可重现性的技术基础：通过 Bazel、Nix 等工具实现完全确定的构建过程，确保相同输入产生相同输出，支持审计与回溯。

5. 自动化验证是规模化的前提：人工审查无法跟上现代 CI/CD 的速度与规模，需依赖自动化扫描、签名验证、准入控制形成防线。

---

## 导航

**[← 7.3 开源治理](./7.3_open_source_governance.md)** | **[返回章节目录](./README.md)** | **[7.5 容器镜像供应链安全 →](./7.5_container_supply_chain_security.md)**

---

**© 2025 AI-ESA Project. Licensed under CC BY-NC-SA 4.0**

